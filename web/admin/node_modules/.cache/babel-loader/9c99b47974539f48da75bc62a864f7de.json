{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/**\n * TinyMCE version 6.2.0 (2022-09-08)\n */\n\n(function () {\n  'use strict';\n\n  var global$6 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n  const hasProto = (v, constructor, predicate) => {\n    var _a;\n    if (predicate(v, constructor.prototype)) {\n      return true;\n    } else {\n      return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n    }\n  };\n  const typeOf = x => {\n    const t = typeof x;\n    if (x === null) {\n      return 'null';\n    } else if (t === 'object' && Array.isArray(x)) {\n      return 'array';\n    } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n      return 'string';\n    } else {\n      return t;\n    }\n  };\n  const isType$1 = type => value => typeOf(value) === type;\n  const isSimpleType = type => value => typeof value === type;\n  const isString = isType$1('string');\n  const isObject = isType$1('object');\n  const isArray = isType$1('array');\n  const isBoolean = isSimpleType('boolean');\n  const isNullable = a => a === null || a === undefined;\n  const isNonNullable = a => !isNullable(a);\n  const isFunction = isSimpleType('function');\n  const isNumber = isSimpleType('number');\n  const noop = () => {};\n  const constant = value => {\n    return () => {\n      return value;\n    };\n  };\n  const tripleEquals = (a, b) => {\n    return a === b;\n  };\n  const not = f => t => !f(t);\n  const never = constant(false);\n  class Optional {\n    constructor(tag, value) {\n      this.tag = tag;\n      this.value = value;\n    }\n    static some(value) {\n      return new Optional(true, value);\n    }\n    static none() {\n      return Optional.singletonNone;\n    }\n    fold(onNone, onSome) {\n      if (this.tag) {\n        return onSome(this.value);\n      } else {\n        return onNone();\n      }\n    }\n    isSome() {\n      return this.tag;\n    }\n    isNone() {\n      return !this.tag;\n    }\n    map(mapper) {\n      if (this.tag) {\n        return Optional.some(mapper(this.value));\n      } else {\n        return Optional.none();\n      }\n    }\n    bind(binder) {\n      if (this.tag) {\n        return binder(this.value);\n      } else {\n        return Optional.none();\n      }\n    }\n    exists(predicate) {\n      return this.tag && predicate(this.value);\n    }\n    forall(predicate) {\n      return !this.tag || predicate(this.value);\n    }\n    filter(predicate) {\n      if (!this.tag || predicate(this.value)) {\n        return this;\n      } else {\n        return Optional.none();\n      }\n    }\n    getOr(replacement) {\n      return this.tag ? this.value : replacement;\n    }\n    or(replacement) {\n      return this.tag ? this : replacement;\n    }\n    getOrThunk(thunk) {\n      return this.tag ? this.value : thunk();\n    }\n    orThunk(thunk) {\n      return this.tag ? this : thunk();\n    }\n    getOrDie(message) {\n      if (!this.tag) {\n        throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n      } else {\n        return this.value;\n      }\n    }\n    static from(value) {\n      return isNonNullable(value) ? Optional.some(value) : Optional.none();\n    }\n    getOrNull() {\n      return this.tag ? this.value : null;\n    }\n    getOrUndefined() {\n      return this.value;\n    }\n    each(worker) {\n      if (this.tag) {\n        worker(this.value);\n      }\n    }\n    toArray() {\n      return this.tag ? [this.value] : [];\n    }\n    toString() {\n      return this.tag ? `some(${this.value})` : 'none()';\n    }\n  }\n  Optional.singletonNone = new Optional(false);\n  const nativeSlice = Array.prototype.slice;\n  const nativeIndexOf = Array.prototype.indexOf;\n  const nativePush = Array.prototype.push;\n  const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n  const contains$1 = (xs, x) => rawIndexOf(xs, x) > -1;\n  const exists = (xs, pred) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      if (pred(x, i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  const map = (xs, f) => {\n    const len = xs.length;\n    const r = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const x = xs[i];\n      r[i] = f(x, i);\n    }\n    return r;\n  };\n  const each$1 = (xs, f) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      f(x, i);\n    }\n  };\n  const filter$1 = (xs, pred) => {\n    const r = [];\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      if (pred(x, i)) {\n        r.push(x);\n      }\n    }\n    return r;\n  };\n  const groupBy = (xs, f) => {\n    if (xs.length === 0) {\n      return [];\n    } else {\n      let wasType = f(xs[0]);\n      const r = [];\n      let group = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        const type = f(x);\n        if (type !== wasType) {\n          r.push(group);\n          group = [];\n        }\n        wasType = type;\n        group.push(x);\n      }\n      if (group.length !== 0) {\n        r.push(group);\n      }\n      return r;\n    }\n  };\n  const foldl = (xs, f, acc) => {\n    each$1(xs, (x, i) => {\n      acc = f(acc, x, i);\n    });\n    return acc;\n  };\n  const findUntil = (xs, pred, until) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      if (pred(x, i)) {\n        return Optional.some(x);\n      } else if (until(x, i)) {\n        break;\n      }\n    }\n    return Optional.none();\n  };\n  const find = (xs, pred) => {\n    return findUntil(xs, pred, never);\n  };\n  const flatten = xs => {\n    const r = [];\n    for (let i = 0, len = xs.length; i < len; ++i) {\n      if (!isArray(xs[i])) {\n        throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n      }\n      nativePush.apply(r, xs[i]);\n    }\n    return r;\n  };\n  const bind = (xs, f) => flatten(map(xs, f));\n  const reverse = xs => {\n    const r = nativeSlice.call(xs, 0);\n    r.reverse();\n    return r;\n  };\n  const get$1 = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n  const head = xs => get$1(xs, 0);\n  const last = xs => get$1(xs, xs.length - 1);\n  const unique = (xs, comparator) => {\n    const r = [];\n    const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$1(r, x);\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      if (!isDuplicated(x)) {\n        r.push(x);\n      }\n    }\n    return r;\n  };\n  const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n  const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n  const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n  const ELEMENT = 1;\n  const fromHtml = (html, scope) => {\n    const doc = scope || document;\n    const div = doc.createElement('div');\n    div.innerHTML = html;\n    if (!div.hasChildNodes() || div.childNodes.length > 1) {\n      const message = 'HTML does not have a single root node';\n      console.error(message, html);\n      throw new Error(message);\n    }\n    return fromDom$1(div.childNodes[0]);\n  };\n  const fromTag = (tag, scope) => {\n    const doc = scope || document;\n    const node = doc.createElement(tag);\n    return fromDom$1(node);\n  };\n  const fromText = (text, scope) => {\n    const doc = scope || document;\n    const node = doc.createTextNode(text);\n    return fromDom$1(node);\n  };\n  const fromDom$1 = node => {\n    if (node === null || node === undefined) {\n      throw new Error('Node cannot be null or undefined');\n    }\n    return {\n      dom: node\n    };\n  };\n  const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);\n  const SugarElement = {\n    fromHtml,\n    fromTag,\n    fromText,\n    fromDom: fromDom$1,\n    fromPoint\n  };\n  const is$1 = (element, selector) => {\n    const dom = element.dom;\n    if (dom.nodeType !== ELEMENT) {\n      return false;\n    } else {\n      const elem = dom;\n      if (elem.matches !== undefined) {\n        return elem.matches(selector);\n      } else if (elem.msMatchesSelector !== undefined) {\n        return elem.msMatchesSelector(selector);\n      } else if (elem.webkitMatchesSelector !== undefined) {\n        return elem.webkitMatchesSelector(selector);\n      } else if (elem.mozMatchesSelector !== undefined) {\n        return elem.mozMatchesSelector(selector);\n      } else {\n        throw new Error('Browser lacks native selectors');\n      }\n    }\n  };\n  const eq = (e1, e2) => e1.dom === e2.dom;\n  const contains = (e1, e2) => {\n    const d1 = e1.dom;\n    const d2 = e2.dom;\n    return d1 === d2 ? false : d1.contains(d2);\n  };\n  const is = is$1;\n  var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n    if (is(scope, a)) {\n      return Optional.some(scope);\n    } else if (isFunction(isRoot) && isRoot(scope)) {\n      return Optional.none();\n    } else {\n      return ancestor(scope, a, isRoot);\n    }\n  };\n  typeof window !== 'undefined' ? window : Function('return this;')();\n  const name = element => {\n    const r = element.dom.nodeName;\n    return r.toLowerCase();\n  };\n  const type = element => element.dom.nodeType;\n  const isType = t => element => type(element) === t;\n  const isElement$1 = isType(ELEMENT);\n  const isTag = tag => e => isElement$1(e) && name(e) === tag;\n  const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n  const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n  const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n  const children = element => map(element.dom.childNodes, SugarElement.fromDom);\n  const child = (element, index) => {\n    const cs = element.dom.childNodes;\n    return Optional.from(cs[index]).map(SugarElement.fromDom);\n  };\n  const firstChild = element => child(element, 0);\n  const lastChild = element => child(element, element.dom.childNodes.length - 1);\n  const ancestor = (scope, predicate, isRoot) => {\n    let element = scope.dom;\n    const stop = isFunction(isRoot) ? isRoot : never;\n    while (element.parentNode) {\n      element = element.parentNode;\n      const el = SugarElement.fromDom(element);\n      if (predicate(el)) {\n        return Optional.some(el);\n      } else if (stop(el)) {\n        break;\n      }\n    }\n    return Optional.none();\n  };\n  const closest = (scope, predicate, isRoot) => {\n    const is = (s, test) => test(s);\n    return ClosestOrAncestor(is, ancestor, scope, predicate, isRoot);\n  };\n  const before$1 = (marker, element) => {\n    const parent$1 = parent(marker);\n    parent$1.each(v => {\n      v.dom.insertBefore(element.dom, marker.dom);\n    });\n  };\n  const after = (marker, element) => {\n    const sibling = nextSibling(marker);\n    sibling.fold(() => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        append$1(v, element);\n      });\n    }, v => {\n      before$1(v, element);\n    });\n  };\n  const append$1 = (parent, element) => {\n    parent.dom.appendChild(element.dom);\n  };\n  const before = (marker, elements) => {\n    each$1(elements, x => {\n      before$1(marker, x);\n    });\n  };\n  const append = (parent, elements) => {\n    each$1(elements, x => {\n      append$1(parent, x);\n    });\n  };\n  const empty = element => {\n    element.dom.textContent = '';\n    each$1(children(element), rogue => {\n      remove(rogue);\n    });\n  };\n  const remove = element => {\n    const dom = element.dom;\n    if (dom.parentNode !== null) {\n      dom.parentNode.removeChild(dom);\n    }\n  };\n  var global$5 = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils');\n  var global$4 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');\n  var global$3 = tinymce.util.Tools.resolve('tinymce.util.VK');\n  const fromDom = nodes => map(nodes, SugarElement.fromDom);\n  const keys = Object.keys;\n  const each = (obj, f) => {\n    const props = keys(obj);\n    for (let k = 0, len = props.length; k < len; k++) {\n      const i = props[k];\n      const x = obj[i];\n      f(x, i);\n    }\n  };\n  const objAcc = r => (x, i) => {\n    r[i] = x;\n  };\n  const internalFilter = (obj, pred, onTrue, onFalse) => {\n    each(obj, (x, i) => {\n      (pred(x, i) ? onTrue : onFalse)(x, i);\n    });\n  };\n  const filter = (obj, pred) => {\n    const t = {};\n    internalFilter(obj, pred, objAcc(t), noop);\n    return t;\n  };\n  const rawSet = (dom, key, value) => {\n    if (isString(value) || isBoolean(value) || isNumber(value)) {\n      dom.setAttribute(key, value + '');\n    } else {\n      console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n      throw new Error('Attribute value was not simple');\n    }\n  };\n  const setAll = (element, attrs) => {\n    const dom = element.dom;\n    each(attrs, (v, k) => {\n      rawSet(dom, k, v);\n    });\n  };\n  const clone$1 = element => foldl(element.dom.attributes, (acc, attr) => {\n    acc[attr.name] = attr.value;\n    return acc;\n  }, {});\n  const clone = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n  const deep = original => clone(original, true);\n  const shallowAs = (original, tag) => {\n    const nu = SugarElement.fromTag(tag);\n    const attributes = clone$1(original);\n    setAll(nu, attributes);\n    return nu;\n  };\n  const mutate = (original, tag) => {\n    const nu = shallowAs(original, tag);\n    after(original, nu);\n    const children$1 = children(original);\n    append(nu, children$1);\n    remove(original);\n    return nu;\n  };\n  var global$2 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\n  var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n  const matchNodeName = name => node => isNonNullable(node) && node.nodeName.toLowerCase() === name;\n  const matchNodeNames = regex => node => isNonNullable(node) && regex.test(node.nodeName);\n  const isTextNode = node => isNonNullable(node) && node.nodeType === 3;\n  const isElement = node => isNonNullable(node) && node.nodeType === 1;\n  const isListNode = matchNodeNames(/^(OL|UL|DL)$/);\n  const isOlUlNode = matchNodeNames(/^(OL|UL)$/);\n  const isOlNode = matchNodeName('ol');\n  const isListItemNode = matchNodeNames(/^(LI|DT|DD)$/);\n  const isDlItemNode = matchNodeNames(/^(DT|DD)$/);\n  const isTableCellNode = matchNodeNames(/^(TH|TD)$/);\n  const isBr = matchNodeName('br');\n  const isFirstChild = node => {\n    var _a;\n    return ((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === node;\n  };\n  const isTextBlock = (editor, node) => isNonNullable(node) && node.nodeName in editor.schema.getTextBlockElements();\n  const isBlock = (node, blockElements) => isNonNullable(node) && node.nodeName in blockElements;\n  const isBogusBr = (dom, node) => {\n    if (!isBr(node)) {\n      return false;\n    }\n    return dom.isBlock(node.nextSibling) && !isBr(node.previousSibling);\n  };\n  const isEmpty$1 = (dom, elm, keepBookmarks) => {\n    const empty = dom.isEmpty(elm);\n    if (keepBookmarks && dom.select('span[data-mce-type=bookmark]', elm).length > 0) {\n      return false;\n    }\n    return empty;\n  };\n  const isChildOfBody = (dom, elm) => dom.isChildOf(elm, dom.getRoot());\n  const option = name => editor => editor.options.get(name);\n  const register$3 = editor => {\n    const registerOption = editor.options.register;\n    registerOption('lists_indent_on_tab', {\n      processor: 'boolean',\n      default: true\n    });\n  };\n  const shouldIndentOnTab = option('lists_indent_on_tab');\n  const getForcedRootBlock = option('forced_root_block');\n  const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n  const createTextBlock = (editor, contentNode) => {\n    const dom = editor.dom;\n    const blockElements = editor.schema.getBlockElements();\n    const fragment = dom.createFragment();\n    const blockName = getForcedRootBlock(editor);\n    const blockAttrs = getForcedRootBlockAttrs(editor);\n    let node;\n    let textBlock;\n    let hasContentNode = false;\n    textBlock = dom.create(blockName, blockAttrs);\n    if (!isBlock(contentNode.firstChild, blockElements)) {\n      fragment.appendChild(textBlock);\n    }\n    while (node = contentNode.firstChild) {\n      const nodeName = node.nodeName;\n      if (!hasContentNode && (nodeName !== 'SPAN' || node.getAttribute('data-mce-type') !== 'bookmark')) {\n        hasContentNode = true;\n      }\n      if (isBlock(node, blockElements)) {\n        fragment.appendChild(node);\n        textBlock = null;\n      } else {\n        if (!textBlock) {\n          textBlock = dom.create(blockName, blockAttrs);\n          fragment.appendChild(textBlock);\n        }\n        textBlock.appendChild(node);\n      }\n    }\n    if (!hasContentNode && textBlock) {\n      textBlock.appendChild(dom.create('br', {\n        'data-mce-bogus': '1'\n      }));\n    }\n    return fragment;\n  };\n  const DOM$2 = global$2.DOM;\n  const splitList = (editor, list, li) => {\n    const removeAndKeepBookmarks = targetNode => {\n      const parent = targetNode.parentNode;\n      if (parent) {\n        global$1.each(bookmarks, node => {\n          parent.insertBefore(node, li.parentNode);\n        });\n      }\n      DOM$2.remove(targetNode);\n    };\n    const bookmarks = DOM$2.select('span[data-mce-type=\"bookmark\"]', list);\n    const newBlock = createTextBlock(editor, li);\n    const tmpRng = DOM$2.createRng();\n    tmpRng.setStartAfter(li);\n    tmpRng.setEndAfter(list);\n    const fragment = tmpRng.extractContents();\n    for (let node = fragment.firstChild; node; node = node.firstChild) {\n      if (node.nodeName === 'LI' && editor.dom.isEmpty(node)) {\n        DOM$2.remove(node);\n        break;\n      }\n    }\n    if (!editor.dom.isEmpty(fragment)) {\n      DOM$2.insertAfter(fragment, list);\n    }\n    DOM$2.insertAfter(newBlock, list);\n    const parent = li.parentElement;\n    if (parent && isEmpty$1(editor.dom, parent)) {\n      removeAndKeepBookmarks(parent);\n    }\n    DOM$2.remove(li);\n    if (isEmpty$1(editor.dom, list)) {\n      DOM$2.remove(list);\n    }\n  };\n  const isDescriptionDetail = isTag('dd');\n  const isDescriptionTerm = isTag('dt');\n  const outdentDlItem = (editor, item) => {\n    if (isDescriptionDetail(item)) {\n      mutate(item, 'dt');\n    } else if (isDescriptionTerm(item)) {\n      parentElement(item).each(dl => splitList(editor, dl.dom, item.dom));\n    }\n  };\n  const indentDlItem = item => {\n    if (isDescriptionTerm(item)) {\n      mutate(item, 'dd');\n    }\n  };\n  const dlIndentation = (editor, indentation, dlItems) => {\n    if (indentation === 'Indent') {\n      each$1(dlItems, indentDlItem);\n    } else {\n      each$1(dlItems, item => outdentDlItem(editor, item));\n    }\n  };\n  const getNormalizedPoint = (container, offset) => {\n    if (isTextNode(container)) {\n      return {\n        container,\n        offset\n      };\n    }\n    const node = global$5.getNode(container, offset);\n    if (isTextNode(node)) {\n      return {\n        container: node,\n        offset: offset >= container.childNodes.length ? node.data.length : 0\n      };\n    } else if (node.previousSibling && isTextNode(node.previousSibling)) {\n      return {\n        container: node.previousSibling,\n        offset: node.previousSibling.data.length\n      };\n    } else if (node.nextSibling && isTextNode(node.nextSibling)) {\n      return {\n        container: node.nextSibling,\n        offset: 0\n      };\n    }\n    return {\n      container,\n      offset\n    };\n  };\n  const normalizeRange = rng => {\n    const outRng = rng.cloneRange();\n    const rangeStart = getNormalizedPoint(rng.startContainer, rng.startOffset);\n    outRng.setStart(rangeStart.container, rangeStart.offset);\n    const rangeEnd = getNormalizedPoint(rng.endContainer, rng.endOffset);\n    outRng.setEnd(rangeEnd.container, rangeEnd.offset);\n    return outRng;\n  };\n  const listNames = ['OL', 'UL', 'DL'];\n  const listSelector = listNames.join(',');\n  const getParentList = (editor, node) => {\n    const selectionStart = node || editor.selection.getStart(true);\n    return editor.dom.getParent(selectionStart, listSelector, getClosestListHost(editor, selectionStart));\n  };\n  const isParentListSelected = (parentList, selectedBlocks) => isNonNullable(parentList) && selectedBlocks.length === 1 && selectedBlocks[0] === parentList;\n  const findSubLists = parentList => filter$1(parentList.querySelectorAll(listSelector), isListNode);\n  const getSelectedSubLists = editor => {\n    const parentList = getParentList(editor);\n    const selectedBlocks = editor.selection.getSelectedBlocks();\n    if (isParentListSelected(parentList, selectedBlocks)) {\n      return findSubLists(parentList);\n    } else {\n      return filter$1(selectedBlocks, elm => {\n        return isListNode(elm) && parentList !== elm;\n      });\n    }\n  };\n  const findParentListItemsNodes = (editor, elms) => {\n    const listItemsElms = global$1.map(elms, elm => {\n      const parentLi = editor.dom.getParent(elm, 'li,dd,dt', getClosestListHost(editor, elm));\n      return parentLi ? parentLi : elm;\n    });\n    return unique(listItemsElms);\n  };\n  const getSelectedListItems = editor => {\n    const selectedBlocks = editor.selection.getSelectedBlocks();\n    return filter$1(findParentListItemsNodes(editor, selectedBlocks), isListItemNode);\n  };\n  const getSelectedDlItems = editor => filter$1(getSelectedListItems(editor), isDlItemNode);\n  const getClosestEditingHost = (editor, elm) => {\n    const parentTableCell = editor.dom.getParents(elm, 'TD,TH');\n    return parentTableCell.length > 0 ? parentTableCell[0] : editor.getBody();\n  };\n  const isListHost = (schema, node) => !isListNode(node) && !isListItemNode(node) && exists(listNames, listName => schema.isValidChild(node.nodeName, listName));\n  const getClosestListHost = (editor, elm) => {\n    const parentBlocks = editor.dom.getParents(elm, editor.dom.isBlock);\n    const parentBlock = find(parentBlocks, elm => isListHost(editor.schema, elm));\n    return parentBlock.getOr(editor.getBody());\n  };\n  const findLastParentListNode = (editor, elm) => {\n    const parentLists = editor.dom.getParents(elm, 'ol,ul', getClosestListHost(editor, elm));\n    return last(parentLists);\n  };\n  const getSelectedLists = editor => {\n    const firstList = findLastParentListNode(editor, editor.selection.getStart());\n    const subsequentLists = filter$1(editor.selection.getSelectedBlocks(), isOlUlNode);\n    return firstList.toArray().concat(subsequentLists);\n  };\n  const getSelectedListRoots = editor => {\n    const selectedLists = getSelectedLists(editor);\n    return getUniqueListRoots(editor, selectedLists);\n  };\n  const getUniqueListRoots = (editor, lists) => {\n    const listRoots = map(lists, list => findLastParentListNode(editor, list).getOr(list));\n    return unique(listRoots);\n  };\n  const isCustomList = list => /\\btox\\-/.test(list.className);\n  const inList = (parents, listName) => findUntil(parents, isListNode, isTableCellNode).exists(list => list.nodeName === listName && !isCustomList(list));\n  const isWithinNonEditable = (editor, element) => element !== null && editor.dom.getContentEditableParent(element) === 'false';\n  const selectionIsWithinNonEditableList = editor => {\n    const parentList = getParentList(editor);\n    return isWithinNonEditable(editor, parentList);\n  };\n  const isWithinNonEditableList = (editor, element) => {\n    const parentList = editor.dom.getParent(element, 'ol,ul,dl');\n    return isWithinNonEditable(editor, parentList);\n  };\n  const setNodeChangeHandler = (editor, nodeChangeHandler) => {\n    const initialNode = editor.selection.getNode();\n    nodeChangeHandler({\n      parents: editor.dom.getParents(initialNode),\n      element: initialNode\n    });\n    editor.on('NodeChange', nodeChangeHandler);\n    return () => editor.off('NodeChange', nodeChangeHandler);\n  };\n  const fromElements = (elements, scope) => {\n    const doc = scope || document;\n    const fragment = doc.createDocumentFragment();\n    each$1(elements, element => {\n      fragment.appendChild(element.dom);\n    });\n    return SugarElement.fromDom(fragment);\n  };\n  const fireListEvent = (editor, action, element) => editor.dispatch('ListMutation', {\n    action,\n    element\n  });\n  const blank = r => s => s.replace(r, '');\n  const trim = blank(/^\\s+|\\s+$/g);\n  const isNotEmpty = s => s.length > 0;\n  const isEmpty = s => !isNotEmpty(s);\n  const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n  const internalSet = (dom, property, value) => {\n    if (!isString(value)) {\n      console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n      throw new Error('CSS value must be a string: ' + value);\n    }\n    if (isSupported(dom)) {\n      dom.style.setProperty(property, value);\n    }\n  };\n  const set = (element, property, value) => {\n    const dom = element.dom;\n    internalSet(dom, property, value);\n  };\n  const joinSegment = (parent, child) => {\n    append$1(parent.item, child.list);\n  };\n  const joinSegments = segments => {\n    for (let i = 1; i < segments.length; i++) {\n      joinSegment(segments[i - 1], segments[i]);\n    }\n  };\n  const appendSegments = (head$1, tail) => {\n    lift2(last(head$1), head(tail), joinSegment);\n  };\n  const createSegment = (scope, listType) => {\n    const segment = {\n      list: SugarElement.fromTag(listType, scope),\n      item: SugarElement.fromTag('li', scope)\n    };\n    append$1(segment.list, segment.item);\n    return segment;\n  };\n  const createSegments = (scope, entry, size) => {\n    const segments = [];\n    for (let i = 0; i < size; i++) {\n      segments.push(createSegment(scope, entry.listType));\n    }\n    return segments;\n  };\n  const populateSegments = (segments, entry) => {\n    for (let i = 0; i < segments.length - 1; i++) {\n      set(segments[i].item, 'list-style-type', 'none');\n    }\n    last(segments).each(segment => {\n      setAll(segment.list, entry.listAttributes);\n      setAll(segment.item, entry.itemAttributes);\n      append(segment.item, entry.content);\n    });\n  };\n  const normalizeSegment = (segment, entry) => {\n    if (name(segment.list) !== entry.listType) {\n      segment.list = mutate(segment.list, entry.listType);\n    }\n    setAll(segment.list, entry.listAttributes);\n  };\n  const createItem = (scope, attr, content) => {\n    const item = SugarElement.fromTag('li', scope);\n    setAll(item, attr);\n    append(item, content);\n    return item;\n  };\n  const appendItem = (segment, item) => {\n    append$1(segment.list, item);\n    segment.item = item;\n  };\n  const writeShallow = (scope, cast, entry) => {\n    const newCast = cast.slice(0, entry.depth);\n    last(newCast).each(segment => {\n      const item = createItem(scope, entry.itemAttributes, entry.content);\n      appendItem(segment, item);\n      normalizeSegment(segment, entry);\n    });\n    return newCast;\n  };\n  const writeDeep = (scope, cast, entry) => {\n    const segments = createSegments(scope, entry, entry.depth - cast.length);\n    joinSegments(segments);\n    populateSegments(segments, entry);\n    appendSegments(cast, segments);\n    return cast.concat(segments);\n  };\n  const composeList = (scope, entries) => {\n    const cast = foldl(entries, (cast, entry) => {\n      return entry.depth > cast.length ? writeDeep(scope, cast, entry) : writeShallow(scope, cast, entry);\n    }, []);\n    return head(cast).map(segment => segment.list);\n  };\n  const isList = el => is(el, 'OL,UL');\n  const hasFirstChildList = el => firstChild(el).exists(isList);\n  const hasLastChildList = el => lastChild(el).exists(isList);\n  const isIndented = entry => entry.depth > 0;\n  const isSelected = entry => entry.isSelected;\n  const cloneItemContent = li => {\n    const children$1 = children(li);\n    const content = hasLastChildList(li) ? children$1.slice(0, -1) : children$1;\n    return map(content, deep);\n  };\n  const createEntry = (li, depth, isSelected) => parent(li).filter(isElement$1).map(list => ({\n    depth,\n    dirty: false,\n    isSelected,\n    content: cloneItemContent(li),\n    itemAttributes: clone$1(li),\n    listAttributes: clone$1(list),\n    listType: name(list)\n  }));\n  const indentEntry = (indentation, entry) => {\n    switch (indentation) {\n      case 'Indent':\n        entry.depth++;\n        break;\n      case 'Outdent':\n        entry.depth--;\n        break;\n      case 'Flatten':\n        entry.depth = 0;\n    }\n    entry.dirty = true;\n  };\n  const cloneListProperties = (target, source) => {\n    target.listType = source.listType;\n    target.listAttributes = {\n      ...source.listAttributes\n    };\n  };\n  const cleanListProperties = entry => {\n    entry.listAttributes = filter(entry.listAttributes, (_value, key) => key !== 'start');\n  };\n  const closestSiblingEntry = (entries, start) => {\n    const depth = entries[start].depth;\n    const matches = entry => entry.depth === depth && !entry.dirty;\n    const until = entry => entry.depth < depth;\n    return findUntil(reverse(entries.slice(0, start)), matches, until).orThunk(() => findUntil(entries.slice(start + 1), matches, until));\n  };\n  const normalizeEntries = entries => {\n    each$1(entries, (entry, i) => {\n      closestSiblingEntry(entries, i).fold(() => {\n        if (entry.dirty) {\n          cleanListProperties(entry);\n        }\n      }, matchingEntry => cloneListProperties(entry, matchingEntry));\n    });\n    return entries;\n  };\n  const Cell = initial => {\n    let value = initial;\n    const get = () => {\n      return value;\n    };\n    const set = v => {\n      value = v;\n    };\n    return {\n      get,\n      set\n    };\n  };\n  const parseItem = (depth, itemSelection, selectionState, item) => firstChild(item).filter(isList).fold(() => {\n    itemSelection.each(selection => {\n      if (eq(selection.start, item)) {\n        selectionState.set(true);\n      }\n    });\n    const currentItemEntry = createEntry(item, depth, selectionState.get());\n    itemSelection.each(selection => {\n      if (eq(selection.end, item)) {\n        selectionState.set(false);\n      }\n    });\n    const childListEntries = lastChild(item).filter(isList).map(list => parseList(depth, itemSelection, selectionState, list)).getOr([]);\n    return currentItemEntry.toArray().concat(childListEntries);\n  }, list => parseList(depth, itemSelection, selectionState, list));\n  const parseList = (depth, itemSelection, selectionState, list) => bind(children(list), element => {\n    const parser = isList(element) ? parseList : parseItem;\n    const newDepth = depth + 1;\n    return parser(newDepth, itemSelection, selectionState, element);\n  });\n  const parseLists = (lists, itemSelection) => {\n    const selectionState = Cell(false);\n    const initialDepth = 0;\n    return map(lists, list => ({\n      sourceList: list,\n      entries: parseList(initialDepth, itemSelection, selectionState, list)\n    }));\n  };\n  const outdentedComposer = (editor, entries) => {\n    const normalizedEntries = normalizeEntries(entries);\n    return map(normalizedEntries, entry => {\n      const content = fromElements(entry.content);\n      return SugarElement.fromDom(createTextBlock(editor, content.dom));\n    });\n  };\n  const indentedComposer = (editor, entries) => {\n    const normalizedEntries = normalizeEntries(entries);\n    return composeList(editor.contentDocument, normalizedEntries).toArray();\n  };\n  const composeEntries = (editor, entries) => bind(groupBy(entries, isIndented), entries => {\n    const groupIsIndented = head(entries).exists(isIndented);\n    return groupIsIndented ? indentedComposer(editor, entries) : outdentedComposer(editor, entries);\n  });\n  const indentSelectedEntries = (entries, indentation) => {\n    each$1(filter$1(entries, isSelected), entry => indentEntry(indentation, entry));\n  };\n  const getItemSelection = editor => {\n    const selectedListItems = map(getSelectedListItems(editor), SugarElement.fromDom);\n    return lift2(find(selectedListItems, not(hasFirstChildList)), find(reverse(selectedListItems), not(hasFirstChildList)), (start, end) => ({\n      start,\n      end\n    }));\n  };\n  const listIndentation = (editor, lists, indentation) => {\n    const entrySets = parseLists(lists, getItemSelection(editor));\n    each$1(entrySets, entrySet => {\n      indentSelectedEntries(entrySet.entries, indentation);\n      const composedLists = composeEntries(editor, entrySet.entries);\n      each$1(composedLists, composedList => {\n        fireListEvent(editor, indentation === 'Indent' ? 'IndentList' : 'OutdentList', composedList.dom);\n      });\n      before(entrySet.sourceList, composedLists);\n      remove(entrySet.sourceList);\n    });\n  };\n  const selectionIndentation = (editor, indentation) => {\n    const lists = fromDom(getSelectedListRoots(editor));\n    const dlItems = fromDom(getSelectedDlItems(editor));\n    let isHandled = false;\n    if (lists.length || dlItems.length) {\n      const bookmark = editor.selection.getBookmark();\n      listIndentation(editor, lists, indentation);\n      dlIndentation(editor, indentation, dlItems);\n      editor.selection.moveToBookmark(bookmark);\n      editor.selection.setRng(normalizeRange(editor.selection.getRng()));\n      editor.nodeChanged();\n      isHandled = true;\n    }\n    return isHandled;\n  };\n  const handleIndentation = (editor, indentation) => !selectionIsWithinNonEditableList(editor) && selectionIndentation(editor, indentation);\n  const indentListSelection = editor => handleIndentation(editor, 'Indent');\n  const outdentListSelection = editor => handleIndentation(editor, 'Outdent');\n  const flattenListSelection = editor => handleIndentation(editor, 'Flatten');\n  var global = tinymce.util.Tools.resolve('tinymce.dom.BookmarkManager');\n  const DOM$1 = global$2.DOM;\n  const createBookmark = rng => {\n    const bookmark = {};\n    const setupEndPoint = start => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      let offset = rng[start ? 'startOffset' : 'endOffset'];\n      if (isElement(container)) {\n        const offsetNode = DOM$1.create('span', {\n          'data-mce-type': 'bookmark'\n        });\n        if (container.hasChildNodes()) {\n          offset = Math.min(offset, container.childNodes.length - 1);\n          if (start) {\n            container.insertBefore(offsetNode, container.childNodes[offset]);\n          } else {\n            DOM$1.insertAfter(offsetNode, container.childNodes[offset]);\n          }\n        } else {\n          container.appendChild(offsetNode);\n        }\n        container = offsetNode;\n        offset = 0;\n      }\n      bookmark[start ? 'startContainer' : 'endContainer'] = container;\n      bookmark[start ? 'startOffset' : 'endOffset'] = offset;\n    };\n    setupEndPoint(true);\n    if (!rng.collapsed) {\n      setupEndPoint();\n    }\n    return bookmark;\n  };\n  const resolveBookmark = bookmark => {\n    const restoreEndPoint = start => {\n      const nodeIndex = container => {\n        var _a;\n        let node = (_a = container.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild;\n        let idx = 0;\n        while (node) {\n          if (node === container) {\n            return idx;\n          }\n          if (!isElement(node) || node.getAttribute('data-mce-type') !== 'bookmark') {\n            idx++;\n          }\n          node = node.nextSibling;\n        }\n        return -1;\n      };\n      let container = bookmark[start ? 'startContainer' : 'endContainer'];\n      let offset = bookmark[start ? 'startOffset' : 'endOffset'];\n      if (!container) {\n        return;\n      }\n      if (isElement(container) && container.parentNode) {\n        const node = container;\n        offset = nodeIndex(container);\n        container = container.parentNode;\n        DOM$1.remove(node);\n        if (!container.hasChildNodes() && DOM$1.isBlock(container)) {\n          container.appendChild(DOM$1.create('br'));\n        }\n      }\n      bookmark[start ? 'startContainer' : 'endContainer'] = container;\n      bookmark[start ? 'startOffset' : 'endOffset'] = offset;\n    };\n    restoreEndPoint(true);\n    restoreEndPoint();\n    const rng = DOM$1.createRng();\n    rng.setStart(bookmark.startContainer, bookmark.startOffset);\n    if (bookmark.endContainer) {\n      rng.setEnd(bookmark.endContainer, bookmark.endOffset);\n    }\n    return normalizeRange(rng);\n  };\n  const listToggleActionFromListName = listName => {\n    switch (listName) {\n      case 'UL':\n        return 'ToggleUlList';\n      case 'OL':\n        return 'ToggleOlList';\n      case 'DL':\n        return 'ToggleDLList';\n    }\n  };\n  const updateListStyle = (dom, el, detail) => {\n    const type = detail['list-style-type'] ? detail['list-style-type'] : null;\n    dom.setStyle(el, 'list-style-type', type);\n  };\n  const setAttribs = (elm, attrs) => {\n    global$1.each(attrs, (value, key) => {\n      elm.setAttribute(key, value);\n    });\n  };\n  const updateListAttrs = (dom, el, detail) => {\n    setAttribs(el, detail['list-attributes']);\n    global$1.each(dom.select('li', el), li => {\n      setAttribs(li, detail['list-item-attributes']);\n    });\n  };\n  const updateListWithDetails = (dom, el, detail) => {\n    updateListStyle(dom, el, detail);\n    updateListAttrs(dom, el, detail);\n  };\n  const removeStyles = (dom, element, styles) => {\n    global$1.each(styles, style => dom.setStyle(element, style, ''));\n  };\n  const getEndPointNode = (editor, rng, start, root) => {\n    let container = rng[start ? 'startContainer' : 'endContainer'];\n    const offset = rng[start ? 'startOffset' : 'endOffset'];\n    if (isElement(container)) {\n      container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n    }\n    if (!start && isBr(container.nextSibling)) {\n      container = container.nextSibling;\n    }\n    while (container.parentNode !== root) {\n      const parent = container.parentNode;\n      if (isTextBlock(editor, container)) {\n        return container;\n      }\n      if (/^(TD|TH)$/.test(parent.nodeName)) {\n        return container;\n      }\n      container = parent;\n    }\n    return container;\n  };\n  const getSelectedTextBlocks = (editor, rng, root) => {\n    const textBlocks = [];\n    const dom = editor.dom;\n    const startNode = getEndPointNode(editor, rng, true, root);\n    const endNode = getEndPointNode(editor, rng, false, root);\n    let block;\n    const siblings = [];\n    for (let node = startNode; node; node = node.nextSibling) {\n      siblings.push(node);\n      if (node === endNode) {\n        break;\n      }\n    }\n    global$1.each(siblings, node => {\n      var _a;\n      if (isTextBlock(editor, node)) {\n        textBlocks.push(node);\n        block = null;\n        return;\n      }\n      if (dom.isBlock(node) || isBr(node)) {\n        if (isBr(node)) {\n          dom.remove(node);\n        }\n        block = null;\n        return;\n      }\n      const nextSibling = node.nextSibling;\n      if (global.isBookmarkNode(node)) {\n        if (isListNode(nextSibling) || isTextBlock(editor, nextSibling) || !nextSibling && node.parentNode === root) {\n          block = null;\n          return;\n        }\n      }\n      if (!block) {\n        block = dom.create('p');\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(block, node);\n        textBlocks.push(block);\n      }\n      block.appendChild(node);\n    });\n    return textBlocks;\n  };\n  const hasCompatibleStyle = (dom, sib, detail) => {\n    const sibStyle = dom.getStyle(sib, 'list-style-type');\n    let detailStyle = detail ? detail['list-style-type'] : '';\n    detailStyle = detailStyle === null ? '' : detailStyle;\n    return sibStyle === detailStyle;\n  };\n  const applyList = (editor, listName, detail) => {\n    const rng = editor.selection.getRng();\n    let listItemName = 'LI';\n    const root = getClosestListHost(editor, editor.selection.getStart(true));\n    const dom = editor.dom;\n    if (dom.getContentEditable(editor.selection.getNode()) === 'false') {\n      return;\n    }\n    listName = listName.toUpperCase();\n    if (listName === 'DL') {\n      listItemName = 'DT';\n    }\n    const bookmark = createBookmark(rng);\n    const selectedTextBlocks = getSelectedTextBlocks(editor, rng, root);\n    global$1.each(selectedTextBlocks, block => {\n      let listBlock;\n      const sibling = block.previousSibling;\n      const parent = block.parentNode;\n      if (!isListItemNode(parent)) {\n        if (sibling && isListNode(sibling) && sibling.nodeName === listName && hasCompatibleStyle(dom, sibling, detail)) {\n          listBlock = sibling;\n          block = dom.rename(block, listItemName);\n          sibling.appendChild(block);\n        } else {\n          listBlock = dom.create(listName);\n          parent.insertBefore(listBlock, block);\n          listBlock.appendChild(block);\n          block = dom.rename(block, listItemName);\n        }\n        removeStyles(dom, block, ['margin', 'margin-right', 'margin-bottom', 'margin-left', 'margin-top', 'padding', 'padding-right', 'padding-bottom', 'padding-left', 'padding-top']);\n        updateListWithDetails(dom, listBlock, detail);\n        mergeWithAdjacentLists(editor.dom, listBlock);\n      }\n    });\n    editor.selection.setRng(resolveBookmark(bookmark));\n  };\n  const isValidLists = (list1, list2) => {\n    return isListNode(list1) && list1.nodeName === (list2 === null || list2 === void 0 ? void 0 : list2.nodeName);\n  };\n  const hasSameListStyle = (dom, list1, list2) => {\n    const targetStyle = dom.getStyle(list1, 'list-style-type', true);\n    const style = dom.getStyle(list2, 'list-style-type', true);\n    return targetStyle === style;\n  };\n  const hasSameClasses = (elm1, elm2) => {\n    return elm1.className === elm2.className;\n  };\n  const shouldMerge = (dom, list1, list2) => {\n    return isValidLists(list1, list2) && hasSameListStyle(dom, list1, list2) && hasSameClasses(list1, list2);\n  };\n  const mergeWithAdjacentLists = (dom, listBlock) => {\n    let node;\n    let sibling = listBlock.nextSibling;\n    if (shouldMerge(dom, listBlock, sibling)) {\n      const liSibling = sibling;\n      while (node = liSibling.firstChild) {\n        listBlock.appendChild(node);\n      }\n      dom.remove(liSibling);\n    }\n    sibling = listBlock.previousSibling;\n    if (shouldMerge(dom, listBlock, sibling)) {\n      const liSibling = sibling;\n      while (node = liSibling.lastChild) {\n        listBlock.insertBefore(node, listBlock.firstChild);\n      }\n      dom.remove(liSibling);\n    }\n  };\n  const updateList$1 = (editor, list, listName, detail) => {\n    if (list.nodeName !== listName) {\n      const newList = editor.dom.rename(list, listName);\n      updateListWithDetails(editor.dom, newList, detail);\n      fireListEvent(editor, listToggleActionFromListName(listName), newList);\n    } else {\n      updateListWithDetails(editor.dom, list, detail);\n      fireListEvent(editor, listToggleActionFromListName(listName), list);\n    }\n  };\n  const toggleMultipleLists = (editor, parentList, lists, listName, detail) => {\n    const parentIsList = isListNode(parentList);\n    if (parentIsList && parentList.nodeName === listName && !hasListStyleDetail(detail)) {\n      flattenListSelection(editor);\n    } else {\n      applyList(editor, listName, detail);\n      const bookmark = createBookmark(editor.selection.getRng());\n      const allLists = parentIsList ? [parentList, ...lists] : lists;\n      global$1.each(allLists, elm => {\n        updateList$1(editor, elm, listName, detail);\n      });\n      editor.selection.setRng(resolveBookmark(bookmark));\n    }\n  };\n  const hasListStyleDetail = detail => {\n    return 'list-style-type' in detail;\n  };\n  const toggleSingleList = (editor, parentList, listName, detail) => {\n    if (parentList === editor.getBody()) {\n      return;\n    }\n    if (parentList) {\n      if (parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) {\n        flattenListSelection(editor);\n      } else {\n        const bookmark = createBookmark(editor.selection.getRng());\n        updateListWithDetails(editor.dom, parentList, detail);\n        const newList = editor.dom.rename(parentList, listName);\n        mergeWithAdjacentLists(editor.dom, newList);\n        editor.selection.setRng(resolveBookmark(bookmark));\n        applyList(editor, listName, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), newList);\n      }\n    } else {\n      applyList(editor, listName, detail);\n      fireListEvent(editor, listToggleActionFromListName(listName), parentList);\n    }\n  };\n  const toggleList = (editor, listName, _detail) => {\n    const parentList = getParentList(editor);\n    if (isWithinNonEditableList(editor, parentList)) {\n      return;\n    }\n    const selectedSubLists = getSelectedSubLists(editor);\n    const detail = isObject(_detail) ? _detail : {};\n    if (selectedSubLists.length > 0) {\n      toggleMultipleLists(editor, parentList, selectedSubLists, listName, detail);\n    } else {\n      toggleSingleList(editor, parentList, listName, detail);\n    }\n  };\n  const DOM = global$2.DOM;\n  const normalizeList = (dom, list) => {\n    const parentNode = list.parentElement;\n    if (parentNode && parentNode.nodeName === 'LI' && parentNode.firstChild === list) {\n      const sibling = parentNode.previousSibling;\n      if (sibling && sibling.nodeName === 'LI') {\n        sibling.appendChild(list);\n        if (isEmpty$1(dom, parentNode)) {\n          DOM.remove(parentNode);\n        }\n      } else {\n        DOM.setStyle(parentNode, 'listStyleType', 'none');\n      }\n    }\n    if (isListNode(parentNode)) {\n      const sibling = parentNode.previousSibling;\n      if (sibling && sibling.nodeName === 'LI') {\n        sibling.appendChild(list);\n      }\n    }\n  };\n  const normalizeLists = (dom, element) => {\n    const lists = global$1.grep(dom.select('ol,ul', element));\n    global$1.each(lists, list => {\n      normalizeList(dom, list);\n    });\n  };\n  const findNextCaretContainer = (editor, rng, isForward, root) => {\n    let node = rng.startContainer;\n    const offset = rng.startOffset;\n    if (isTextNode(node) && (isForward ? offset < node.data.length : offset > 0)) {\n      return node;\n    }\n    const nonEmptyBlocks = editor.schema.getNonEmptyElements();\n    if (isElement(node)) {\n      node = global$5.getNode(node, offset);\n    }\n    const walker = new global$4(node, root);\n    if (isForward) {\n      if (isBogusBr(editor.dom, node)) {\n        walker.next();\n      }\n    }\n    const walkFn = isForward ? walker.next.bind(walker) : walker.prev2.bind(walker);\n    while (node = walkFn()) {\n      if (node.nodeName === 'LI' && !node.hasChildNodes()) {\n        return node;\n      }\n      if (nonEmptyBlocks[node.nodeName]) {\n        return node;\n      }\n      if (isTextNode(node) && node.data.length > 0) {\n        return node;\n      }\n    }\n    return null;\n  };\n  const hasOnlyOneBlockChild = (dom, elm) => {\n    const childNodes = elm.childNodes;\n    return childNodes.length === 1 && !isListNode(childNodes[0]) && dom.isBlock(childNodes[0]);\n  };\n  const unwrapSingleBlockChild = (dom, elm) => {\n    if (hasOnlyOneBlockChild(dom, elm)) {\n      dom.remove(elm.firstChild, true);\n    }\n  };\n  const moveChildren = (dom, fromElm, toElm) => {\n    let node;\n    const targetElm = hasOnlyOneBlockChild(dom, toElm) ? toElm.firstChild : toElm;\n    unwrapSingleBlockChild(dom, fromElm);\n    if (!isEmpty$1(dom, fromElm, true)) {\n      while (node = fromElm.firstChild) {\n        targetElm.appendChild(node);\n      }\n    }\n  };\n  const mergeLiElements = (dom, fromElm, toElm) => {\n    let listNode;\n    const ul = fromElm.parentNode;\n    if (!isChildOfBody(dom, fromElm) || !isChildOfBody(dom, toElm)) {\n      return;\n    }\n    if (isListNode(toElm.lastChild)) {\n      listNode = toElm.lastChild;\n    }\n    if (ul === toElm.lastChild) {\n      if (isBr(ul.previousSibling)) {\n        dom.remove(ul.previousSibling);\n      }\n    }\n    const node = toElm.lastChild;\n    if (node && isBr(node) && fromElm.hasChildNodes()) {\n      dom.remove(node);\n    }\n    if (isEmpty$1(dom, toElm, true)) {\n      empty(SugarElement.fromDom(toElm));\n    }\n    moveChildren(dom, fromElm, toElm);\n    if (listNode) {\n      toElm.appendChild(listNode);\n    }\n    const contains$1 = contains(SugarElement.fromDom(toElm), SugarElement.fromDom(fromElm));\n    const nestedLists = contains$1 ? dom.getParents(fromElm, isListNode, toElm) : [];\n    dom.remove(fromElm);\n    each$1(nestedLists, list => {\n      if (isEmpty$1(dom, list) && list !== dom.getRoot()) {\n        dom.remove(list);\n      }\n    });\n  };\n  const mergeIntoEmptyLi = (editor, fromLi, toLi) => {\n    empty(SugarElement.fromDom(toLi));\n    mergeLiElements(editor.dom, fromLi, toLi);\n    editor.selection.setCursorLocation(toLi, 0);\n  };\n  const mergeForward = (editor, rng, fromLi, toLi) => {\n    const dom = editor.dom;\n    if (dom.isEmpty(toLi)) {\n      mergeIntoEmptyLi(editor, fromLi, toLi);\n    } else {\n      const bookmark = createBookmark(rng);\n      mergeLiElements(dom, fromLi, toLi);\n      editor.selection.setRng(resolveBookmark(bookmark));\n    }\n  };\n  const mergeBackward = (editor, rng, fromLi, toLi) => {\n    const bookmark = createBookmark(rng);\n    mergeLiElements(editor.dom, fromLi, toLi);\n    const resolvedBookmark = resolveBookmark(bookmark);\n    editor.selection.setRng(resolvedBookmark);\n  };\n  const backspaceDeleteFromListToListCaret = (editor, isForward) => {\n    const dom = editor.dom,\n      selection = editor.selection;\n    const selectionStartElm = selection.getStart();\n    const root = getClosestEditingHost(editor, selectionStartElm);\n    const li = dom.getParent(selection.getStart(), 'LI', root);\n    if (li) {\n      const ul = li.parentElement;\n      if (ul === editor.getBody() && isEmpty$1(dom, ul)) {\n        return true;\n      }\n      const rng = normalizeRange(selection.getRng());\n      const otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), 'LI', root);\n      if (otherLi && otherLi !== li) {\n        editor.undoManager.transact(() => {\n          if (isForward) {\n            mergeForward(editor, rng, otherLi, li);\n          } else {\n            if (isFirstChild(li)) {\n              outdentListSelection(editor);\n            } else {\n              mergeBackward(editor, rng, li, otherLi);\n            }\n          }\n        });\n        return true;\n      } else if (!otherLi) {\n        if (!isForward && rng.startOffset === 0 && rng.endOffset === 0) {\n          editor.undoManager.transact(() => {\n            flattenListSelection(editor);\n          });\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  const removeBlock = (dom, block, root) => {\n    const parentBlock = dom.getParent(block.parentNode, dom.isBlock, root);\n    dom.remove(block);\n    if (parentBlock && dom.isEmpty(parentBlock)) {\n      dom.remove(parentBlock);\n    }\n  };\n  const backspaceDeleteIntoListCaret = (editor, isForward) => {\n    const dom = editor.dom;\n    const selectionStartElm = editor.selection.getStart();\n    const root = getClosestEditingHost(editor, selectionStartElm);\n    const block = dom.getParent(selectionStartElm, dom.isBlock, root);\n    if (block && dom.isEmpty(block)) {\n      const rng = normalizeRange(editor.selection.getRng());\n      const otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), 'LI', root);\n      if (otherLi) {\n        const findValidElement = element => contains$1(['td', 'th', 'caption'], name(element));\n        const findRoot = node => node.dom === root;\n        const otherLiCell = closest(SugarElement.fromDom(otherLi), findValidElement, findRoot);\n        const caretCell = closest(SugarElement.fromDom(rng.startContainer), findValidElement, findRoot);\n        if (!equals(otherLiCell, caretCell, eq)) {\n          return false;\n        }\n        editor.undoManager.transact(() => {\n          removeBlock(dom, block, root);\n          mergeWithAdjacentLists(dom, otherLi.parentNode);\n          editor.selection.select(otherLi, true);\n          editor.selection.collapse(isForward);\n        });\n        return true;\n      }\n    }\n    return false;\n  };\n  const backspaceDeleteCaret = (editor, isForward) => {\n    return backspaceDeleteFromListToListCaret(editor, isForward) || backspaceDeleteIntoListCaret(editor, isForward);\n  };\n  const hasListSelection = editor => {\n    const selectionStartElm = editor.selection.getStart();\n    const root = getClosestEditingHost(editor, selectionStartElm);\n    const startListParent = editor.dom.getParent(selectionStartElm, 'LI,DT,DD', root);\n    return startListParent || getSelectedListItems(editor).length > 0;\n  };\n  const backspaceDeleteRange = editor => {\n    if (hasListSelection(editor)) {\n      editor.undoManager.transact(() => {\n        editor.execCommand('Delete');\n        normalizeLists(editor.dom, editor.getBody());\n      });\n      return true;\n    }\n    return false;\n  };\n  const backspaceDelete = (editor, isForward) => {\n    const selection = editor.selection;\n    return !isWithinNonEditableList(editor, selection.getNode()) && (selection.isCollapsed() ? backspaceDeleteCaret(editor, isForward) : backspaceDeleteRange(editor));\n  };\n  const setup$1 = editor => {\n    editor.on('ExecCommand', e => {\n      const cmd = e.command.toLowerCase();\n      if ((cmd === 'delete' || cmd === 'forwarddelete') && hasListSelection(editor)) {\n        normalizeLists(editor.dom, editor.getBody());\n      }\n    });\n    editor.on('keydown', e => {\n      if (e.keyCode === global$3.BACKSPACE) {\n        if (backspaceDelete(editor, false)) {\n          e.preventDefault();\n        }\n      } else if (e.keyCode === global$3.DELETE) {\n        if (backspaceDelete(editor, true)) {\n          e.preventDefault();\n        }\n      }\n    });\n  };\n  const get = editor => ({\n    backspaceDelete: isForward => {\n      backspaceDelete(editor, isForward);\n    }\n  });\n  const updateList = (editor, update) => {\n    const parentList = getParentList(editor);\n    if (parentList === null || isWithinNonEditableList(editor, parentList)) {\n      return;\n    }\n    editor.undoManager.transact(() => {\n      if (isObject(update.styles)) {\n        editor.dom.setStyles(parentList, update.styles);\n      }\n      if (isObject(update.attrs)) {\n        each(update.attrs, (v, k) => editor.dom.setAttrib(parentList, k, v));\n      }\n    });\n  };\n  const parseAlphabeticBase26 = str => {\n    const chars = reverse(trim(str).split(''));\n    const values = map(chars, (char, i) => {\n      const charValue = char.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0) + 1;\n      return Math.pow(26, i) * charValue;\n    });\n    return foldl(values, (sum, v) => sum + v, 0);\n  };\n  const composeAlphabeticBase26 = value => {\n    value--;\n    if (value < 0) {\n      return '';\n    } else {\n      const remainder = value % 26;\n      const quotient = Math.floor(value / 26);\n      const rest = composeAlphabeticBase26(quotient);\n      const char = String.fromCharCode('A'.charCodeAt(0) + remainder);\n      return rest + char;\n    }\n  };\n  const isUppercase = str => /^[A-Z]+$/.test(str);\n  const isLowercase = str => /^[a-z]+$/.test(str);\n  const isNumeric = str => /^[0-9]+$/.test(str);\n  const deduceListType = start => {\n    if (isNumeric(start)) {\n      return 2;\n    } else if (isUppercase(start)) {\n      return 0;\n    } else if (isLowercase(start)) {\n      return 1;\n    } else if (isEmpty(start)) {\n      return 3;\n    } else {\n      return 4;\n    }\n  };\n  const parseStartValue = start => {\n    switch (deduceListType(start)) {\n      case 2:\n        return Optional.some({\n          listStyleType: Optional.none(),\n          start\n        });\n      case 0:\n        return Optional.some({\n          listStyleType: Optional.some('upper-alpha'),\n          start: parseAlphabeticBase26(start).toString()\n        });\n      case 1:\n        return Optional.some({\n          listStyleType: Optional.some('lower-alpha'),\n          start: parseAlphabeticBase26(start).toString()\n        });\n      case 3:\n        return Optional.some({\n          listStyleType: Optional.none(),\n          start: ''\n        });\n      case 4:\n        return Optional.none();\n    }\n  };\n  const parseDetail = detail => {\n    const start = parseInt(detail.start, 10);\n    if (is$2(detail.listStyleType, 'upper-alpha')) {\n      return composeAlphabeticBase26(start);\n    } else if (is$2(detail.listStyleType, 'lower-alpha')) {\n      return composeAlphabeticBase26(start).toLowerCase();\n    } else {\n      return detail.start;\n    }\n  };\n  const open = editor => {\n    const currentList = getParentList(editor);\n    if (!isOlNode(currentList) || isWithinNonEditableList(editor, currentList)) {\n      return;\n    }\n    editor.windowManager.open({\n      title: 'List Properties',\n      body: {\n        type: 'panel',\n        items: [{\n          type: 'input',\n          name: 'start',\n          label: 'Start list at number',\n          inputMode: 'numeric'\n        }]\n      },\n      initialData: {\n        start: parseDetail({\n          start: editor.dom.getAttrib(currentList, 'start', '1'),\n          listStyleType: Optional.from(editor.dom.getStyle(currentList, 'list-style-type'))\n        })\n      },\n      buttons: [{\n        type: 'cancel',\n        name: 'cancel',\n        text: 'Cancel'\n      }, {\n        type: 'submit',\n        name: 'save',\n        text: 'Save',\n        primary: true\n      }],\n      onSubmit: api => {\n        const data = api.getData();\n        parseStartValue(data.start).each(detail => {\n          editor.execCommand('mceListUpdate', false, {\n            attrs: {\n              start: detail.start === '1' ? '' : detail.start\n            },\n            styles: {\n              'list-style-type': detail.listStyleType.getOr('')\n            }\n          });\n        });\n        api.close();\n      }\n    });\n  };\n  const queryListCommandState = (editor, listName) => () => {\n    const parentList = getParentList(editor);\n    return isNonNullable(parentList) && parentList.nodeName === listName;\n  };\n  const registerDialog = editor => {\n    editor.addCommand('mceListProps', () => {\n      open(editor);\n    });\n  };\n  const register$2 = editor => {\n    editor.on('BeforeExecCommand', e => {\n      const cmd = e.command.toLowerCase();\n      if (cmd === 'indent') {\n        indentListSelection(editor);\n      } else if (cmd === 'outdent') {\n        outdentListSelection(editor);\n      }\n    });\n    editor.addCommand('InsertUnorderedList', (ui, detail) => {\n      toggleList(editor, 'UL', detail);\n    });\n    editor.addCommand('InsertOrderedList', (ui, detail) => {\n      toggleList(editor, 'OL', detail);\n    });\n    editor.addCommand('InsertDefinitionList', (ui, detail) => {\n      toggleList(editor, 'DL', detail);\n    });\n    editor.addCommand('RemoveList', () => {\n      flattenListSelection(editor);\n    });\n    registerDialog(editor);\n    editor.addCommand('mceListUpdate', (ui, detail) => {\n      if (isObject(detail)) {\n        updateList(editor, detail);\n      }\n    });\n    editor.addQueryStateHandler('InsertUnorderedList', queryListCommandState(editor, 'UL'));\n    editor.addQueryStateHandler('InsertOrderedList', queryListCommandState(editor, 'OL'));\n    editor.addQueryStateHandler('InsertDefinitionList', queryListCommandState(editor, 'DL'));\n  };\n  const setupTabKey = editor => {\n    editor.on('keydown', e => {\n      if (e.keyCode !== global$3.TAB || global$3.metaKeyPressed(e)) {\n        return;\n      }\n      editor.undoManager.transact(() => {\n        if (e.shiftKey ? outdentListSelection(editor) : indentListSelection(editor)) {\n          e.preventDefault();\n        }\n      });\n    });\n  };\n  const setup = editor => {\n    if (shouldIndentOnTab(editor)) {\n      setupTabKey(editor);\n    }\n    setup$1(editor);\n  };\n  const setupToggleButtonHandler = (editor, listName) => api => {\n    const toggleButtonHandler = e => {\n      api.setActive(inList(e.parents, listName));\n      api.setEnabled(!isWithinNonEditableList(editor, e.element));\n    };\n    return setNodeChangeHandler(editor, toggleButtonHandler);\n  };\n  const register$1 = editor => {\n    const exec = command => () => editor.execCommand(command);\n    if (!editor.hasPlugin('advlist')) {\n      editor.ui.registry.addToggleButton('numlist', {\n        icon: 'ordered-list',\n        active: false,\n        tooltip: 'Numbered list',\n        onAction: exec('InsertOrderedList'),\n        onSetup: setupToggleButtonHandler(editor, 'OL')\n      });\n      editor.ui.registry.addToggleButton('bullist', {\n        icon: 'unordered-list',\n        active: false,\n        tooltip: 'Bullet list',\n        onAction: exec('InsertUnorderedList'),\n        onSetup: setupToggleButtonHandler(editor, 'UL')\n      });\n    }\n  };\n  const setupMenuButtonHandler = (editor, listName) => api => {\n    const menuButtonHandler = e => api.setEnabled(inList(e.parents, listName) && !isWithinNonEditableList(editor, e.element));\n    return setNodeChangeHandler(editor, menuButtonHandler);\n  };\n  const register = editor => {\n    const listProperties = {\n      text: 'List properties...',\n      icon: 'ordered-list',\n      onAction: () => editor.execCommand('mceListProps'),\n      onSetup: setupMenuButtonHandler(editor, 'OL')\n    };\n    editor.ui.registry.addMenuItem('listprops', listProperties);\n    editor.ui.registry.addContextMenu('lists', {\n      update: node => {\n        const parentList = getParentList(editor, node);\n        return isOlNode(parentList) ? ['listprops'] : [];\n      }\n    });\n  };\n  var Plugin = () => {\n    global$6.add('lists', editor => {\n      register$3(editor);\n      if (!editor.hasPlugin('rtc', true)) {\n        setup(editor);\n        register$2(editor);\n      } else {\n        registerDialog(editor);\n      }\n      register$1(editor);\n      register(editor);\n      return get(editor);\n    });\n  };\n  Plugin();\n})();","map":{"version":3,"names":["global$6","tinymce","util","Tools","resolve","hasProto","v","constructor","predicate","_a","prototype","name","typeOf","x","t","Array","isArray","String","o","proto","isPrototypeOf","isType$1","type","value","isSimpleType","isString","isObject","isBoolean","isNullable","a","undefined","isNonNullable","isFunction","isNumber","noop","constant","tripleEquals","b","not","f","never","Optional","tag","some","none","singletonNone","fold","onNone","onSome","isSome","isNone","map","mapper","bind","binder","exists","forall","filter","getOr","replacement","or","getOrThunk","thunk","orThunk","getOrDie","message","Error","from","getOrNull","getOrUndefined","each","worker","toArray","toString","nativeSlice","slice","nativeIndexOf","indexOf","nativePush","push","rawIndexOf","ts","call","contains$1","xs","pred","i","len","length","r","each$1","filter$1","groupBy","wasType","group","foldl","acc","findUntil","until","find","flatten","apply","reverse","get$1","head","last","unique","comparator","isDuplicated","is$2","lhs","rhs","left","equals","lift2","oa","ob","ELEMENT","fromHtml","html","scope","doc","document","div","createElement","innerHTML","hasChildNodes","childNodes","console","error","fromDom$1","fromTag","node","fromText","text","createTextNode","dom","fromPoint","docElm","y","elementFromPoint","SugarElement","fromDom","is$1","element","selector","nodeType","elem","matches","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","eq","e1","e2","contains","d1","d2","is","ClosestOrAncestor","ancestor","isRoot","window","Function","nodeName","toLowerCase","isType","isElement$1","isTag","e","parent","parentNode","parentElement","nextSibling","children","child","index","cs","firstChild","lastChild","stop","el","closest","s","test","before$1","marker","parent$1","insertBefore","after","sibling","append$1","appendChild","before","elements","append","empty","textContent","rogue","remove","removeChild","global$5","global$4","global$3","nodes","keys","Object","obj","props","k","objAcc","internalFilter","onTrue","onFalse","rawSet","key","setAttribute","setAll","attrs","clone$1","attributes","attr","clone","original","isDeep","cloneNode","deep","shallowAs","nu","mutate","children$1","global$2","global$1","matchNodeName","matchNodeNames","regex","isTextNode","isElement","isListNode","isOlUlNode","isOlNode","isListItemNode","isDlItemNode","isTableCellNode","isBr","isFirstChild","isTextBlock","editor","schema","getTextBlockElements","isBlock","blockElements","isBogusBr","previousSibling","isEmpty$1","elm","keepBookmarks","isEmpty","select","isChildOfBody","isChildOf","getRoot","option","options","get","register$3","registerOption","register","processor","default","shouldIndentOnTab","getForcedRootBlock","getForcedRootBlockAttrs","createTextBlock","contentNode","getBlockElements","fragment","createFragment","blockName","blockAttrs","textBlock","hasContentNode","create","getAttribute","DOM$2","DOM","splitList","list","li","removeAndKeepBookmarks","targetNode","bookmarks","newBlock","tmpRng","createRng","setStartAfter","setEndAfter","extractContents","insertAfter","isDescriptionDetail","isDescriptionTerm","outdentDlItem","item","dl","indentDlItem","dlIndentation","indentation","dlItems","getNormalizedPoint","container","offset","getNode","data","normalizeRange","rng","outRng","cloneRange","rangeStart","startContainer","startOffset","setStart","rangeEnd","endContainer","endOffset","setEnd","listNames","listSelector","join","getParentList","selectionStart","selection","getStart","getParent","getClosestListHost","isParentListSelected","parentList","selectedBlocks","findSubLists","querySelectorAll","getSelectedSubLists","getSelectedBlocks","findParentListItemsNodes","elms","listItemsElms","parentLi","getSelectedListItems","getSelectedDlItems","getClosestEditingHost","parentTableCell","getParents","getBody","isListHost","listName","isValidChild","parentBlocks","parentBlock","findLastParentListNode","parentLists","getSelectedLists","firstList","subsequentLists","concat","getSelectedListRoots","selectedLists","getUniqueListRoots","lists","listRoots","isCustomList","className","inList","parents","isWithinNonEditable","getContentEditableParent","selectionIsWithinNonEditableList","isWithinNonEditableList","setNodeChangeHandler","nodeChangeHandler","initialNode","on","off","fromElements","createDocumentFragment","fireListEvent","action","dispatch","blank","replace","trim","isNotEmpty","isSupported","style","getPropertyValue","internalSet","property","setProperty","set","joinSegment","joinSegments","segments","appendSegments","head$1","tail","createSegment","listType","segment","createSegments","entry","size","populateSegments","listAttributes","itemAttributes","content","normalizeSegment","createItem","appendItem","writeShallow","cast","newCast","depth","writeDeep","composeList","entries","isList","hasFirstChildList","hasLastChildList","isIndented","isSelected","cloneItemContent","createEntry","dirty","indentEntry","cloneListProperties","target","source","cleanListProperties","_value","closestSiblingEntry","start","normalizeEntries","matchingEntry","Cell","initial","parseItem","itemSelection","selectionState","currentItemEntry","end","childListEntries","parseList","parser","newDepth","parseLists","initialDepth","sourceList","outdentedComposer","normalizedEntries","indentedComposer","contentDocument","composeEntries","groupIsIndented","indentSelectedEntries","getItemSelection","selectedListItems","listIndentation","entrySets","entrySet","composedLists","composedList","selectionIndentation","isHandled","bookmark","getBookmark","moveToBookmark","setRng","getRng","nodeChanged","handleIndentation","indentListSelection","outdentListSelection","flattenListSelection","global","DOM$1","createBookmark","setupEndPoint","offsetNode","Math","min","collapsed","resolveBookmark","restoreEndPoint","nodeIndex","idx","listToggleActionFromListName","updateListStyle","detail","setStyle","setAttribs","updateListAttrs","updateListWithDetails","removeStyles","styles","getEndPointNode","root","getSelectedTextBlocks","textBlocks","startNode","endNode","block","siblings","isBookmarkNode","hasCompatibleStyle","sib","sibStyle","getStyle","detailStyle","applyList","listItemName","getContentEditable","toUpperCase","selectedTextBlocks","listBlock","rename","mergeWithAdjacentLists","isValidLists","list1","list2","hasSameListStyle","targetStyle","hasSameClasses","elm1","elm2","shouldMerge","liSibling","updateList$1","newList","toggleMultipleLists","parentIsList","hasListStyleDetail","allLists","toggleSingleList","toggleList","_detail","selectedSubLists","normalizeList","normalizeLists","grep","findNextCaretContainer","isForward","nonEmptyBlocks","getNonEmptyElements","walker","next","walkFn","prev2","hasOnlyOneBlockChild","unwrapSingleBlockChild","moveChildren","fromElm","toElm","targetElm","mergeLiElements","listNode","ul","nestedLists","mergeIntoEmptyLi","fromLi","toLi","setCursorLocation","mergeForward","mergeBackward","resolvedBookmark","backspaceDeleteFromListToListCaret","selectionStartElm","otherLi","undoManager","transact","removeBlock","backspaceDeleteIntoListCaret","findValidElement","findRoot","otherLiCell","caretCell","collapse","backspaceDeleteCaret","hasListSelection","startListParent","backspaceDeleteRange","execCommand","backspaceDelete","isCollapsed","setup$1","cmd","command","keyCode","BACKSPACE","preventDefault","DELETE","updateList","update","setStyles","setAttrib","parseAlphabeticBase26","str","chars","split","values","char","charValue","charCodeAt","pow","sum","composeAlphabeticBase26","remainder","quotient","floor","rest","fromCharCode","isUppercase","isLowercase","isNumeric","deduceListType","parseStartValue","listStyleType","parseDetail","parseInt","open","currentList","windowManager","title","body","items","label","inputMode","initialData","getAttrib","buttons","primary","onSubmit","api","getData","close","queryListCommandState","registerDialog","addCommand","register$2","ui","addQueryStateHandler","setupTabKey","TAB","metaKeyPressed","shiftKey","setup","setupToggleButtonHandler","toggleButtonHandler","setActive","setEnabled","register$1","exec","hasPlugin","registry","addToggleButton","icon","active","tooltip","onAction","onSetup","setupMenuButtonHandler","menuButtonHandler","listProperties","addMenuItem","addContextMenu","Plugin","add"],"sources":["/home/hyq/GoHome/src/ginblog/web/admin/node_modules/tinymce/plugins/lists/plugin.js"],"sourcesContent":["/**\n * TinyMCE version 6.2.0 (2022-09-08)\n */\n\n(function () {\n    'use strict';\n\n    var global$6 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isArray = isType$1('array');\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n\n    const noop = () => {\n    };\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    const not = f => t => !f(t);\n    const never = constant(false);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const contains$1 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const map = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$1 = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const filter$1 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const groupBy = (xs, f) => {\n      if (xs.length === 0) {\n        return [];\n      } else {\n        let wasType = f(xs[0]);\n        const r = [];\n        let group = [];\n        for (let i = 0, len = xs.length; i < len; i++) {\n          const x = xs[i];\n          const type = f(x);\n          if (type !== wasType) {\n            r.push(group);\n            group = [];\n          }\n          wasType = type;\n          group.push(x);\n        }\n        if (group.length !== 0) {\n          r.push(group);\n        }\n        return r;\n      }\n    };\n    const foldl = (xs, f, acc) => {\n      each$1(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find = (xs, pred) => {\n      return findUntil(xs, pred, never);\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind = (xs, f) => flatten(map(xs, f));\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const get$1 = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$1(xs, 0);\n    const last = xs => get$1(xs, xs.length - 1);\n    const unique = (xs, comparator) => {\n      const r = [];\n      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$1(r, x);\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (!isDuplicated(x)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n\n    const ELEMENT = 1;\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$1(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$1(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$1(node);\n    };\n    const fromDom$1 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);\n    const SugarElement = {\n      fromHtml,\n      fromTag,\n      fromText,\n      fromDom: fromDom$1,\n      fromPoint\n    };\n\n    const is$1 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const contains = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n    const is = is$1;\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type = element => element.dom.nodeType;\n    const isType = t => element => type(element) === t;\n    const isElement$1 = isType(ELEMENT);\n    const isTag = tag => e => isElement$1(e) && name(e) === tag;\n\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const children = element => map(element.dom.childNodes, SugarElement.fromDom);\n    const child = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child(element, 0);\n    const lastChild = element => child(element, element.dom.childNodes.length - 1);\n\n    const ancestor = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor, scope, predicate, isRoot);\n    };\n\n    const before$1 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$1(v, element);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n\n    const before = (marker, elements) => {\n      each$1(elements, x => {\n        before$1(marker, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$1(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$1(children(element), rogue => {\n        remove(rogue);\n      });\n    };\n    const remove = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n\n    var global$5 = tinymce.util.Tools.resolve('tinymce.dom.RangeUtils');\n\n    var global$4 = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.util.VK');\n\n    const fromDom = nodes => map(nodes, SugarElement.fromDom);\n\n    const keys = Object.keys;\n    const each = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      each(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n    };\n    const filter = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const setAll = (element, attrs) => {\n      const dom = element.dom;\n      each(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const clone$1 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const clone = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const deep = original => clone(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$1(original);\n      setAll(nu, attributes);\n      return nu;\n    };\n    const mutate = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after(original, nu);\n      const children$1 = children(original);\n      append(nu, children$1);\n      remove(original);\n      return nu;\n    };\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.dom.DOMUtils');\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const matchNodeName = name => node => isNonNullable(node) && node.nodeName.toLowerCase() === name;\n    const matchNodeNames = regex => node => isNonNullable(node) && regex.test(node.nodeName);\n    const isTextNode = node => isNonNullable(node) && node.nodeType === 3;\n    const isElement = node => isNonNullable(node) && node.nodeType === 1;\n    const isListNode = matchNodeNames(/^(OL|UL|DL)$/);\n    const isOlUlNode = matchNodeNames(/^(OL|UL)$/);\n    const isOlNode = matchNodeName('ol');\n    const isListItemNode = matchNodeNames(/^(LI|DT|DD)$/);\n    const isDlItemNode = matchNodeNames(/^(DT|DD)$/);\n    const isTableCellNode = matchNodeNames(/^(TH|TD)$/);\n    const isBr = matchNodeName('br');\n    const isFirstChild = node => {\n      var _a;\n      return ((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === node;\n    };\n    const isTextBlock = (editor, node) => isNonNullable(node) && node.nodeName in editor.schema.getTextBlockElements();\n    const isBlock = (node, blockElements) => isNonNullable(node) && node.nodeName in blockElements;\n    const isBogusBr = (dom, node) => {\n      if (!isBr(node)) {\n        return false;\n      }\n      return dom.isBlock(node.nextSibling) && !isBr(node.previousSibling);\n    };\n    const isEmpty$1 = (dom, elm, keepBookmarks) => {\n      const empty = dom.isEmpty(elm);\n      if (keepBookmarks && dom.select('span[data-mce-type=bookmark]', elm).length > 0) {\n        return false;\n      }\n      return empty;\n    };\n    const isChildOfBody = (dom, elm) => dom.isChildOf(elm, dom.getRoot());\n\n    const option = name => editor => editor.options.get(name);\n    const register$3 = editor => {\n      const registerOption = editor.options.register;\n      registerOption('lists_indent_on_tab', {\n        processor: 'boolean',\n        default: true\n      });\n    };\n    const shouldIndentOnTab = option('lists_indent_on_tab');\n    const getForcedRootBlock = option('forced_root_block');\n    const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n\n    const createTextBlock = (editor, contentNode) => {\n      const dom = editor.dom;\n      const blockElements = editor.schema.getBlockElements();\n      const fragment = dom.createFragment();\n      const blockName = getForcedRootBlock(editor);\n      const blockAttrs = getForcedRootBlockAttrs(editor);\n      let node;\n      let textBlock;\n      let hasContentNode = false;\n      textBlock = dom.create(blockName, blockAttrs);\n      if (!isBlock(contentNode.firstChild, blockElements)) {\n        fragment.appendChild(textBlock);\n      }\n      while (node = contentNode.firstChild) {\n        const nodeName = node.nodeName;\n        if (!hasContentNode && (nodeName !== 'SPAN' || node.getAttribute('data-mce-type') !== 'bookmark')) {\n          hasContentNode = true;\n        }\n        if (isBlock(node, blockElements)) {\n          fragment.appendChild(node);\n          textBlock = null;\n        } else {\n          if (!textBlock) {\n            textBlock = dom.create(blockName, blockAttrs);\n            fragment.appendChild(textBlock);\n          }\n          textBlock.appendChild(node);\n        }\n      }\n      if (!hasContentNode && textBlock) {\n        textBlock.appendChild(dom.create('br', { 'data-mce-bogus': '1' }));\n      }\n      return fragment;\n    };\n\n    const DOM$2 = global$2.DOM;\n    const splitList = (editor, list, li) => {\n      const removeAndKeepBookmarks = targetNode => {\n        const parent = targetNode.parentNode;\n        if (parent) {\n          global$1.each(bookmarks, node => {\n            parent.insertBefore(node, li.parentNode);\n          });\n        }\n        DOM$2.remove(targetNode);\n      };\n      const bookmarks = DOM$2.select('span[data-mce-type=\"bookmark\"]', list);\n      const newBlock = createTextBlock(editor, li);\n      const tmpRng = DOM$2.createRng();\n      tmpRng.setStartAfter(li);\n      tmpRng.setEndAfter(list);\n      const fragment = tmpRng.extractContents();\n      for (let node = fragment.firstChild; node; node = node.firstChild) {\n        if (node.nodeName === 'LI' && editor.dom.isEmpty(node)) {\n          DOM$2.remove(node);\n          break;\n        }\n      }\n      if (!editor.dom.isEmpty(fragment)) {\n        DOM$2.insertAfter(fragment, list);\n      }\n      DOM$2.insertAfter(newBlock, list);\n      const parent = li.parentElement;\n      if (parent && isEmpty$1(editor.dom, parent)) {\n        removeAndKeepBookmarks(parent);\n      }\n      DOM$2.remove(li);\n      if (isEmpty$1(editor.dom, list)) {\n        DOM$2.remove(list);\n      }\n    };\n\n    const isDescriptionDetail = isTag('dd');\n    const isDescriptionTerm = isTag('dt');\n    const outdentDlItem = (editor, item) => {\n      if (isDescriptionDetail(item)) {\n        mutate(item, 'dt');\n      } else if (isDescriptionTerm(item)) {\n        parentElement(item).each(dl => splitList(editor, dl.dom, item.dom));\n      }\n    };\n    const indentDlItem = item => {\n      if (isDescriptionTerm(item)) {\n        mutate(item, 'dd');\n      }\n    };\n    const dlIndentation = (editor, indentation, dlItems) => {\n      if (indentation === 'Indent') {\n        each$1(dlItems, indentDlItem);\n      } else {\n        each$1(dlItems, item => outdentDlItem(editor, item));\n      }\n    };\n\n    const getNormalizedPoint = (container, offset) => {\n      if (isTextNode(container)) {\n        return {\n          container,\n          offset\n        };\n      }\n      const node = global$5.getNode(container, offset);\n      if (isTextNode(node)) {\n        return {\n          container: node,\n          offset: offset >= container.childNodes.length ? node.data.length : 0\n        };\n      } else if (node.previousSibling && isTextNode(node.previousSibling)) {\n        return {\n          container: node.previousSibling,\n          offset: node.previousSibling.data.length\n        };\n      } else if (node.nextSibling && isTextNode(node.nextSibling)) {\n        return {\n          container: node.nextSibling,\n          offset: 0\n        };\n      }\n      return {\n        container,\n        offset\n      };\n    };\n    const normalizeRange = rng => {\n      const outRng = rng.cloneRange();\n      const rangeStart = getNormalizedPoint(rng.startContainer, rng.startOffset);\n      outRng.setStart(rangeStart.container, rangeStart.offset);\n      const rangeEnd = getNormalizedPoint(rng.endContainer, rng.endOffset);\n      outRng.setEnd(rangeEnd.container, rangeEnd.offset);\n      return outRng;\n    };\n\n    const listNames = [\n      'OL',\n      'UL',\n      'DL'\n    ];\n    const listSelector = listNames.join(',');\n    const getParentList = (editor, node) => {\n      const selectionStart = node || editor.selection.getStart(true);\n      return editor.dom.getParent(selectionStart, listSelector, getClosestListHost(editor, selectionStart));\n    };\n    const isParentListSelected = (parentList, selectedBlocks) => isNonNullable(parentList) && selectedBlocks.length === 1 && selectedBlocks[0] === parentList;\n    const findSubLists = parentList => filter$1(parentList.querySelectorAll(listSelector), isListNode);\n    const getSelectedSubLists = editor => {\n      const parentList = getParentList(editor);\n      const selectedBlocks = editor.selection.getSelectedBlocks();\n      if (isParentListSelected(parentList, selectedBlocks)) {\n        return findSubLists(parentList);\n      } else {\n        return filter$1(selectedBlocks, elm => {\n          return isListNode(elm) && parentList !== elm;\n        });\n      }\n    };\n    const findParentListItemsNodes = (editor, elms) => {\n      const listItemsElms = global$1.map(elms, elm => {\n        const parentLi = editor.dom.getParent(elm, 'li,dd,dt', getClosestListHost(editor, elm));\n        return parentLi ? parentLi : elm;\n      });\n      return unique(listItemsElms);\n    };\n    const getSelectedListItems = editor => {\n      const selectedBlocks = editor.selection.getSelectedBlocks();\n      return filter$1(findParentListItemsNodes(editor, selectedBlocks), isListItemNode);\n    };\n    const getSelectedDlItems = editor => filter$1(getSelectedListItems(editor), isDlItemNode);\n    const getClosestEditingHost = (editor, elm) => {\n      const parentTableCell = editor.dom.getParents(elm, 'TD,TH');\n      return parentTableCell.length > 0 ? parentTableCell[0] : editor.getBody();\n    };\n    const isListHost = (schema, node) => !isListNode(node) && !isListItemNode(node) && exists(listNames, listName => schema.isValidChild(node.nodeName, listName));\n    const getClosestListHost = (editor, elm) => {\n      const parentBlocks = editor.dom.getParents(elm, editor.dom.isBlock);\n      const parentBlock = find(parentBlocks, elm => isListHost(editor.schema, elm));\n      return parentBlock.getOr(editor.getBody());\n    };\n    const findLastParentListNode = (editor, elm) => {\n      const parentLists = editor.dom.getParents(elm, 'ol,ul', getClosestListHost(editor, elm));\n      return last(parentLists);\n    };\n    const getSelectedLists = editor => {\n      const firstList = findLastParentListNode(editor, editor.selection.getStart());\n      const subsequentLists = filter$1(editor.selection.getSelectedBlocks(), isOlUlNode);\n      return firstList.toArray().concat(subsequentLists);\n    };\n    const getSelectedListRoots = editor => {\n      const selectedLists = getSelectedLists(editor);\n      return getUniqueListRoots(editor, selectedLists);\n    };\n    const getUniqueListRoots = (editor, lists) => {\n      const listRoots = map(lists, list => findLastParentListNode(editor, list).getOr(list));\n      return unique(listRoots);\n    };\n\n    const isCustomList = list => /\\btox\\-/.test(list.className);\n    const inList = (parents, listName) => findUntil(parents, isListNode, isTableCellNode).exists(list => list.nodeName === listName && !isCustomList(list));\n    const isWithinNonEditable = (editor, element) => element !== null && editor.dom.getContentEditableParent(element) === 'false';\n    const selectionIsWithinNonEditableList = editor => {\n      const parentList = getParentList(editor);\n      return isWithinNonEditable(editor, parentList);\n    };\n    const isWithinNonEditableList = (editor, element) => {\n      const parentList = editor.dom.getParent(element, 'ol,ul,dl');\n      return isWithinNonEditable(editor, parentList);\n    };\n    const setNodeChangeHandler = (editor, nodeChangeHandler) => {\n      const initialNode = editor.selection.getNode();\n      nodeChangeHandler({\n        parents: editor.dom.getParents(initialNode),\n        element: initialNode\n      });\n      editor.on('NodeChange', nodeChangeHandler);\n      return () => editor.off('NodeChange', nodeChangeHandler);\n    };\n\n    const fromElements = (elements, scope) => {\n      const doc = scope || document;\n      const fragment = doc.createDocumentFragment();\n      each$1(elements, element => {\n        fragment.appendChild(element.dom);\n      });\n      return SugarElement.fromDom(fragment);\n    };\n\n    const fireListEvent = (editor, action, element) => editor.dispatch('ListMutation', {\n      action,\n      element\n    });\n\n    const blank = r => s => s.replace(r, '');\n    const trim = blank(/^\\s+|\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const isEmpty = s => !isNotEmpty(s);\n\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const set = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n\n    const joinSegment = (parent, child) => {\n      append$1(parent.item, child.list);\n    };\n    const joinSegments = segments => {\n      for (let i = 1; i < segments.length; i++) {\n        joinSegment(segments[i - 1], segments[i]);\n      }\n    };\n    const appendSegments = (head$1, tail) => {\n      lift2(last(head$1), head(tail), joinSegment);\n    };\n    const createSegment = (scope, listType) => {\n      const segment = {\n        list: SugarElement.fromTag(listType, scope),\n        item: SugarElement.fromTag('li', scope)\n      };\n      append$1(segment.list, segment.item);\n      return segment;\n    };\n    const createSegments = (scope, entry, size) => {\n      const segments = [];\n      for (let i = 0; i < size; i++) {\n        segments.push(createSegment(scope, entry.listType));\n      }\n      return segments;\n    };\n    const populateSegments = (segments, entry) => {\n      for (let i = 0; i < segments.length - 1; i++) {\n        set(segments[i].item, 'list-style-type', 'none');\n      }\n      last(segments).each(segment => {\n        setAll(segment.list, entry.listAttributes);\n        setAll(segment.item, entry.itemAttributes);\n        append(segment.item, entry.content);\n      });\n    };\n    const normalizeSegment = (segment, entry) => {\n      if (name(segment.list) !== entry.listType) {\n        segment.list = mutate(segment.list, entry.listType);\n      }\n      setAll(segment.list, entry.listAttributes);\n    };\n    const createItem = (scope, attr, content) => {\n      const item = SugarElement.fromTag('li', scope);\n      setAll(item, attr);\n      append(item, content);\n      return item;\n    };\n    const appendItem = (segment, item) => {\n      append$1(segment.list, item);\n      segment.item = item;\n    };\n    const writeShallow = (scope, cast, entry) => {\n      const newCast = cast.slice(0, entry.depth);\n      last(newCast).each(segment => {\n        const item = createItem(scope, entry.itemAttributes, entry.content);\n        appendItem(segment, item);\n        normalizeSegment(segment, entry);\n      });\n      return newCast;\n    };\n    const writeDeep = (scope, cast, entry) => {\n      const segments = createSegments(scope, entry, entry.depth - cast.length);\n      joinSegments(segments);\n      populateSegments(segments, entry);\n      appendSegments(cast, segments);\n      return cast.concat(segments);\n    };\n    const composeList = (scope, entries) => {\n      const cast = foldl(entries, (cast, entry) => {\n        return entry.depth > cast.length ? writeDeep(scope, cast, entry) : writeShallow(scope, cast, entry);\n      }, []);\n      return head(cast).map(segment => segment.list);\n    };\n\n    const isList = el => is(el, 'OL,UL');\n    const hasFirstChildList = el => firstChild(el).exists(isList);\n    const hasLastChildList = el => lastChild(el).exists(isList);\n\n    const isIndented = entry => entry.depth > 0;\n    const isSelected = entry => entry.isSelected;\n    const cloneItemContent = li => {\n      const children$1 = children(li);\n      const content = hasLastChildList(li) ? children$1.slice(0, -1) : children$1;\n      return map(content, deep);\n    };\n    const createEntry = (li, depth, isSelected) => parent(li).filter(isElement$1).map(list => ({\n      depth,\n      dirty: false,\n      isSelected,\n      content: cloneItemContent(li),\n      itemAttributes: clone$1(li),\n      listAttributes: clone$1(list),\n      listType: name(list)\n    }));\n\n    const indentEntry = (indentation, entry) => {\n      switch (indentation) {\n      case 'Indent':\n        entry.depth++;\n        break;\n      case 'Outdent':\n        entry.depth--;\n        break;\n      case 'Flatten':\n        entry.depth = 0;\n      }\n      entry.dirty = true;\n    };\n\n    const cloneListProperties = (target, source) => {\n      target.listType = source.listType;\n      target.listAttributes = { ...source.listAttributes };\n    };\n    const cleanListProperties = entry => {\n      entry.listAttributes = filter(entry.listAttributes, (_value, key) => key !== 'start');\n    };\n    const closestSiblingEntry = (entries, start) => {\n      const depth = entries[start].depth;\n      const matches = entry => entry.depth === depth && !entry.dirty;\n      const until = entry => entry.depth < depth;\n      return findUntil(reverse(entries.slice(0, start)), matches, until).orThunk(() => findUntil(entries.slice(start + 1), matches, until));\n    };\n    const normalizeEntries = entries => {\n      each$1(entries, (entry, i) => {\n        closestSiblingEntry(entries, i).fold(() => {\n          if (entry.dirty) {\n            cleanListProperties(entry);\n          }\n        }, matchingEntry => cloneListProperties(entry, matchingEntry));\n      });\n      return entries;\n    };\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const parseItem = (depth, itemSelection, selectionState, item) => firstChild(item).filter(isList).fold(() => {\n      itemSelection.each(selection => {\n        if (eq(selection.start, item)) {\n          selectionState.set(true);\n        }\n      });\n      const currentItemEntry = createEntry(item, depth, selectionState.get());\n      itemSelection.each(selection => {\n        if (eq(selection.end, item)) {\n          selectionState.set(false);\n        }\n      });\n      const childListEntries = lastChild(item).filter(isList).map(list => parseList(depth, itemSelection, selectionState, list)).getOr([]);\n      return currentItemEntry.toArray().concat(childListEntries);\n    }, list => parseList(depth, itemSelection, selectionState, list));\n    const parseList = (depth, itemSelection, selectionState, list) => bind(children(list), element => {\n      const parser = isList(element) ? parseList : parseItem;\n      const newDepth = depth + 1;\n      return parser(newDepth, itemSelection, selectionState, element);\n    });\n    const parseLists = (lists, itemSelection) => {\n      const selectionState = Cell(false);\n      const initialDepth = 0;\n      return map(lists, list => ({\n        sourceList: list,\n        entries: parseList(initialDepth, itemSelection, selectionState, list)\n      }));\n    };\n\n    const outdentedComposer = (editor, entries) => {\n      const normalizedEntries = normalizeEntries(entries);\n      return map(normalizedEntries, entry => {\n        const content = fromElements(entry.content);\n        return SugarElement.fromDom(createTextBlock(editor, content.dom));\n      });\n    };\n    const indentedComposer = (editor, entries) => {\n      const normalizedEntries = normalizeEntries(entries);\n      return composeList(editor.contentDocument, normalizedEntries).toArray();\n    };\n    const composeEntries = (editor, entries) => bind(groupBy(entries, isIndented), entries => {\n      const groupIsIndented = head(entries).exists(isIndented);\n      return groupIsIndented ? indentedComposer(editor, entries) : outdentedComposer(editor, entries);\n    });\n    const indentSelectedEntries = (entries, indentation) => {\n      each$1(filter$1(entries, isSelected), entry => indentEntry(indentation, entry));\n    };\n    const getItemSelection = editor => {\n      const selectedListItems = map(getSelectedListItems(editor), SugarElement.fromDom);\n      return lift2(find(selectedListItems, not(hasFirstChildList)), find(reverse(selectedListItems), not(hasFirstChildList)), (start, end) => ({\n        start,\n        end\n      }));\n    };\n    const listIndentation = (editor, lists, indentation) => {\n      const entrySets = parseLists(lists, getItemSelection(editor));\n      each$1(entrySets, entrySet => {\n        indentSelectedEntries(entrySet.entries, indentation);\n        const composedLists = composeEntries(editor, entrySet.entries);\n        each$1(composedLists, composedList => {\n          fireListEvent(editor, indentation === 'Indent' ? 'IndentList' : 'OutdentList', composedList.dom);\n        });\n        before(entrySet.sourceList, composedLists);\n        remove(entrySet.sourceList);\n      });\n    };\n\n    const selectionIndentation = (editor, indentation) => {\n      const lists = fromDom(getSelectedListRoots(editor));\n      const dlItems = fromDom(getSelectedDlItems(editor));\n      let isHandled = false;\n      if (lists.length || dlItems.length) {\n        const bookmark = editor.selection.getBookmark();\n        listIndentation(editor, lists, indentation);\n        dlIndentation(editor, indentation, dlItems);\n        editor.selection.moveToBookmark(bookmark);\n        editor.selection.setRng(normalizeRange(editor.selection.getRng()));\n        editor.nodeChanged();\n        isHandled = true;\n      }\n      return isHandled;\n    };\n    const handleIndentation = (editor, indentation) => !selectionIsWithinNonEditableList(editor) && selectionIndentation(editor, indentation);\n    const indentListSelection = editor => handleIndentation(editor, 'Indent');\n    const outdentListSelection = editor => handleIndentation(editor, 'Outdent');\n    const flattenListSelection = editor => handleIndentation(editor, 'Flatten');\n\n    var global = tinymce.util.Tools.resolve('tinymce.dom.BookmarkManager');\n\n    const DOM$1 = global$2.DOM;\n    const createBookmark = rng => {\n      const bookmark = {};\n      const setupEndPoint = start => {\n        let container = rng[start ? 'startContainer' : 'endContainer'];\n        let offset = rng[start ? 'startOffset' : 'endOffset'];\n        if (isElement(container)) {\n          const offsetNode = DOM$1.create('span', { 'data-mce-type': 'bookmark' });\n          if (container.hasChildNodes()) {\n            offset = Math.min(offset, container.childNodes.length - 1);\n            if (start) {\n              container.insertBefore(offsetNode, container.childNodes[offset]);\n            } else {\n              DOM$1.insertAfter(offsetNode, container.childNodes[offset]);\n            }\n          } else {\n            container.appendChild(offsetNode);\n          }\n          container = offsetNode;\n          offset = 0;\n        }\n        bookmark[start ? 'startContainer' : 'endContainer'] = container;\n        bookmark[start ? 'startOffset' : 'endOffset'] = offset;\n      };\n      setupEndPoint(true);\n      if (!rng.collapsed) {\n        setupEndPoint();\n      }\n      return bookmark;\n    };\n    const resolveBookmark = bookmark => {\n      const restoreEndPoint = start => {\n        const nodeIndex = container => {\n          var _a;\n          let node = (_a = container.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild;\n          let idx = 0;\n          while (node) {\n            if (node === container) {\n              return idx;\n            }\n            if (!isElement(node) || node.getAttribute('data-mce-type') !== 'bookmark') {\n              idx++;\n            }\n            node = node.nextSibling;\n          }\n          return -1;\n        };\n        let container = bookmark[start ? 'startContainer' : 'endContainer'];\n        let offset = bookmark[start ? 'startOffset' : 'endOffset'];\n        if (!container) {\n          return;\n        }\n        if (isElement(container) && container.parentNode) {\n          const node = container;\n          offset = nodeIndex(container);\n          container = container.parentNode;\n          DOM$1.remove(node);\n          if (!container.hasChildNodes() && DOM$1.isBlock(container)) {\n            container.appendChild(DOM$1.create('br'));\n          }\n        }\n        bookmark[start ? 'startContainer' : 'endContainer'] = container;\n        bookmark[start ? 'startOffset' : 'endOffset'] = offset;\n      };\n      restoreEndPoint(true);\n      restoreEndPoint();\n      const rng = DOM$1.createRng();\n      rng.setStart(bookmark.startContainer, bookmark.startOffset);\n      if (bookmark.endContainer) {\n        rng.setEnd(bookmark.endContainer, bookmark.endOffset);\n      }\n      return normalizeRange(rng);\n    };\n\n    const listToggleActionFromListName = listName => {\n      switch (listName) {\n      case 'UL':\n        return 'ToggleUlList';\n      case 'OL':\n        return 'ToggleOlList';\n      case 'DL':\n        return 'ToggleDLList';\n      }\n    };\n\n    const updateListStyle = (dom, el, detail) => {\n      const type = detail['list-style-type'] ? detail['list-style-type'] : null;\n      dom.setStyle(el, 'list-style-type', type);\n    };\n    const setAttribs = (elm, attrs) => {\n      global$1.each(attrs, (value, key) => {\n        elm.setAttribute(key, value);\n      });\n    };\n    const updateListAttrs = (dom, el, detail) => {\n      setAttribs(el, detail['list-attributes']);\n      global$1.each(dom.select('li', el), li => {\n        setAttribs(li, detail['list-item-attributes']);\n      });\n    };\n    const updateListWithDetails = (dom, el, detail) => {\n      updateListStyle(dom, el, detail);\n      updateListAttrs(dom, el, detail);\n    };\n    const removeStyles = (dom, element, styles) => {\n      global$1.each(styles, style => dom.setStyle(element, style, ''));\n    };\n    const getEndPointNode = (editor, rng, start, root) => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      const offset = rng[start ? 'startOffset' : 'endOffset'];\n      if (isElement(container)) {\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n      }\n      if (!start && isBr(container.nextSibling)) {\n        container = container.nextSibling;\n      }\n      while (container.parentNode !== root) {\n        const parent = container.parentNode;\n        if (isTextBlock(editor, container)) {\n          return container;\n        }\n        if (/^(TD|TH)$/.test(parent.nodeName)) {\n          return container;\n        }\n        container = parent;\n      }\n      return container;\n    };\n    const getSelectedTextBlocks = (editor, rng, root) => {\n      const textBlocks = [];\n      const dom = editor.dom;\n      const startNode = getEndPointNode(editor, rng, true, root);\n      const endNode = getEndPointNode(editor, rng, false, root);\n      let block;\n      const siblings = [];\n      for (let node = startNode; node; node = node.nextSibling) {\n        siblings.push(node);\n        if (node === endNode) {\n          break;\n        }\n      }\n      global$1.each(siblings, node => {\n        var _a;\n        if (isTextBlock(editor, node)) {\n          textBlocks.push(node);\n          block = null;\n          return;\n        }\n        if (dom.isBlock(node) || isBr(node)) {\n          if (isBr(node)) {\n            dom.remove(node);\n          }\n          block = null;\n          return;\n        }\n        const nextSibling = node.nextSibling;\n        if (global.isBookmarkNode(node)) {\n          if (isListNode(nextSibling) || isTextBlock(editor, nextSibling) || !nextSibling && node.parentNode === root) {\n            block = null;\n            return;\n          }\n        }\n        if (!block) {\n          block = dom.create('p');\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(block, node);\n          textBlocks.push(block);\n        }\n        block.appendChild(node);\n      });\n      return textBlocks;\n    };\n    const hasCompatibleStyle = (dom, sib, detail) => {\n      const sibStyle = dom.getStyle(sib, 'list-style-type');\n      let detailStyle = detail ? detail['list-style-type'] : '';\n      detailStyle = detailStyle === null ? '' : detailStyle;\n      return sibStyle === detailStyle;\n    };\n    const applyList = (editor, listName, detail) => {\n      const rng = editor.selection.getRng();\n      let listItemName = 'LI';\n      const root = getClosestListHost(editor, editor.selection.getStart(true));\n      const dom = editor.dom;\n      if (dom.getContentEditable(editor.selection.getNode()) === 'false') {\n        return;\n      }\n      listName = listName.toUpperCase();\n      if (listName === 'DL') {\n        listItemName = 'DT';\n      }\n      const bookmark = createBookmark(rng);\n      const selectedTextBlocks = getSelectedTextBlocks(editor, rng, root);\n      global$1.each(selectedTextBlocks, block => {\n        let listBlock;\n        const sibling = block.previousSibling;\n        const parent = block.parentNode;\n        if (!isListItemNode(parent)) {\n          if (sibling && isListNode(sibling) && sibling.nodeName === listName && hasCompatibleStyle(dom, sibling, detail)) {\n            listBlock = sibling;\n            block = dom.rename(block, listItemName);\n            sibling.appendChild(block);\n          } else {\n            listBlock = dom.create(listName);\n            parent.insertBefore(listBlock, block);\n            listBlock.appendChild(block);\n            block = dom.rename(block, listItemName);\n          }\n          removeStyles(dom, block, [\n            'margin',\n            'margin-right',\n            'margin-bottom',\n            'margin-left',\n            'margin-top',\n            'padding',\n            'padding-right',\n            'padding-bottom',\n            'padding-left',\n            'padding-top'\n          ]);\n          updateListWithDetails(dom, listBlock, detail);\n          mergeWithAdjacentLists(editor.dom, listBlock);\n        }\n      });\n      editor.selection.setRng(resolveBookmark(bookmark));\n    };\n    const isValidLists = (list1, list2) => {\n      return isListNode(list1) && list1.nodeName === (list2 === null || list2 === void 0 ? void 0 : list2.nodeName);\n    };\n    const hasSameListStyle = (dom, list1, list2) => {\n      const targetStyle = dom.getStyle(list1, 'list-style-type', true);\n      const style = dom.getStyle(list2, 'list-style-type', true);\n      return targetStyle === style;\n    };\n    const hasSameClasses = (elm1, elm2) => {\n      return elm1.className === elm2.className;\n    };\n    const shouldMerge = (dom, list1, list2) => {\n      return isValidLists(list1, list2) && hasSameListStyle(dom, list1, list2) && hasSameClasses(list1, list2);\n    };\n    const mergeWithAdjacentLists = (dom, listBlock) => {\n      let node;\n      let sibling = listBlock.nextSibling;\n      if (shouldMerge(dom, listBlock, sibling)) {\n        const liSibling = sibling;\n        while (node = liSibling.firstChild) {\n          listBlock.appendChild(node);\n        }\n        dom.remove(liSibling);\n      }\n      sibling = listBlock.previousSibling;\n      if (shouldMerge(dom, listBlock, sibling)) {\n        const liSibling = sibling;\n        while (node = liSibling.lastChild) {\n          listBlock.insertBefore(node, listBlock.firstChild);\n        }\n        dom.remove(liSibling);\n      }\n    };\n    const updateList$1 = (editor, list, listName, detail) => {\n      if (list.nodeName !== listName) {\n        const newList = editor.dom.rename(list, listName);\n        updateListWithDetails(editor.dom, newList, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), newList);\n      } else {\n        updateListWithDetails(editor.dom, list, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), list);\n      }\n    };\n    const toggleMultipleLists = (editor, parentList, lists, listName, detail) => {\n      const parentIsList = isListNode(parentList);\n      if (parentIsList && parentList.nodeName === listName && !hasListStyleDetail(detail)) {\n        flattenListSelection(editor);\n      } else {\n        applyList(editor, listName, detail);\n        const bookmark = createBookmark(editor.selection.getRng());\n        const allLists = parentIsList ? [\n          parentList,\n          ...lists\n        ] : lists;\n        global$1.each(allLists, elm => {\n          updateList$1(editor, elm, listName, detail);\n        });\n        editor.selection.setRng(resolveBookmark(bookmark));\n      }\n    };\n    const hasListStyleDetail = detail => {\n      return 'list-style-type' in detail;\n    };\n    const toggleSingleList = (editor, parentList, listName, detail) => {\n      if (parentList === editor.getBody()) {\n        return;\n      }\n      if (parentList) {\n        if (parentList.nodeName === listName && !hasListStyleDetail(detail) && !isCustomList(parentList)) {\n          flattenListSelection(editor);\n        } else {\n          const bookmark = createBookmark(editor.selection.getRng());\n          updateListWithDetails(editor.dom, parentList, detail);\n          const newList = editor.dom.rename(parentList, listName);\n          mergeWithAdjacentLists(editor.dom, newList);\n          editor.selection.setRng(resolveBookmark(bookmark));\n          applyList(editor, listName, detail);\n          fireListEvent(editor, listToggleActionFromListName(listName), newList);\n        }\n      } else {\n        applyList(editor, listName, detail);\n        fireListEvent(editor, listToggleActionFromListName(listName), parentList);\n      }\n    };\n    const toggleList = (editor, listName, _detail) => {\n      const parentList = getParentList(editor);\n      if (isWithinNonEditableList(editor, parentList)) {\n        return;\n      }\n      const selectedSubLists = getSelectedSubLists(editor);\n      const detail = isObject(_detail) ? _detail : {};\n      if (selectedSubLists.length > 0) {\n        toggleMultipleLists(editor, parentList, selectedSubLists, listName, detail);\n      } else {\n        toggleSingleList(editor, parentList, listName, detail);\n      }\n    };\n\n    const DOM = global$2.DOM;\n    const normalizeList = (dom, list) => {\n      const parentNode = list.parentElement;\n      if (parentNode && parentNode.nodeName === 'LI' && parentNode.firstChild === list) {\n        const sibling = parentNode.previousSibling;\n        if (sibling && sibling.nodeName === 'LI') {\n          sibling.appendChild(list);\n          if (isEmpty$1(dom, parentNode)) {\n            DOM.remove(parentNode);\n          }\n        } else {\n          DOM.setStyle(parentNode, 'listStyleType', 'none');\n        }\n      }\n      if (isListNode(parentNode)) {\n        const sibling = parentNode.previousSibling;\n        if (sibling && sibling.nodeName === 'LI') {\n          sibling.appendChild(list);\n        }\n      }\n    };\n    const normalizeLists = (dom, element) => {\n      const lists = global$1.grep(dom.select('ol,ul', element));\n      global$1.each(lists, list => {\n        normalizeList(dom, list);\n      });\n    };\n\n    const findNextCaretContainer = (editor, rng, isForward, root) => {\n      let node = rng.startContainer;\n      const offset = rng.startOffset;\n      if (isTextNode(node) && (isForward ? offset < node.data.length : offset > 0)) {\n        return node;\n      }\n      const nonEmptyBlocks = editor.schema.getNonEmptyElements();\n      if (isElement(node)) {\n        node = global$5.getNode(node, offset);\n      }\n      const walker = new global$4(node, root);\n      if (isForward) {\n        if (isBogusBr(editor.dom, node)) {\n          walker.next();\n        }\n      }\n      const walkFn = isForward ? walker.next.bind(walker) : walker.prev2.bind(walker);\n      while (node = walkFn()) {\n        if (node.nodeName === 'LI' && !node.hasChildNodes()) {\n          return node;\n        }\n        if (nonEmptyBlocks[node.nodeName]) {\n          return node;\n        }\n        if (isTextNode(node) && node.data.length > 0) {\n          return node;\n        }\n      }\n      return null;\n    };\n    const hasOnlyOneBlockChild = (dom, elm) => {\n      const childNodes = elm.childNodes;\n      return childNodes.length === 1 && !isListNode(childNodes[0]) && dom.isBlock(childNodes[0]);\n    };\n    const unwrapSingleBlockChild = (dom, elm) => {\n      if (hasOnlyOneBlockChild(dom, elm)) {\n        dom.remove(elm.firstChild, true);\n      }\n    };\n    const moveChildren = (dom, fromElm, toElm) => {\n      let node;\n      const targetElm = hasOnlyOneBlockChild(dom, toElm) ? toElm.firstChild : toElm;\n      unwrapSingleBlockChild(dom, fromElm);\n      if (!isEmpty$1(dom, fromElm, true)) {\n        while (node = fromElm.firstChild) {\n          targetElm.appendChild(node);\n        }\n      }\n    };\n    const mergeLiElements = (dom, fromElm, toElm) => {\n      let listNode;\n      const ul = fromElm.parentNode;\n      if (!isChildOfBody(dom, fromElm) || !isChildOfBody(dom, toElm)) {\n        return;\n      }\n      if (isListNode(toElm.lastChild)) {\n        listNode = toElm.lastChild;\n      }\n      if (ul === toElm.lastChild) {\n        if (isBr(ul.previousSibling)) {\n          dom.remove(ul.previousSibling);\n        }\n      }\n      const node = toElm.lastChild;\n      if (node && isBr(node) && fromElm.hasChildNodes()) {\n        dom.remove(node);\n      }\n      if (isEmpty$1(dom, toElm, true)) {\n        empty(SugarElement.fromDom(toElm));\n      }\n      moveChildren(dom, fromElm, toElm);\n      if (listNode) {\n        toElm.appendChild(listNode);\n      }\n      const contains$1 = contains(SugarElement.fromDom(toElm), SugarElement.fromDom(fromElm));\n      const nestedLists = contains$1 ? dom.getParents(fromElm, isListNode, toElm) : [];\n      dom.remove(fromElm);\n      each$1(nestedLists, list => {\n        if (isEmpty$1(dom, list) && list !== dom.getRoot()) {\n          dom.remove(list);\n        }\n      });\n    };\n    const mergeIntoEmptyLi = (editor, fromLi, toLi) => {\n      empty(SugarElement.fromDom(toLi));\n      mergeLiElements(editor.dom, fromLi, toLi);\n      editor.selection.setCursorLocation(toLi, 0);\n    };\n    const mergeForward = (editor, rng, fromLi, toLi) => {\n      const dom = editor.dom;\n      if (dom.isEmpty(toLi)) {\n        mergeIntoEmptyLi(editor, fromLi, toLi);\n      } else {\n        const bookmark = createBookmark(rng);\n        mergeLiElements(dom, fromLi, toLi);\n        editor.selection.setRng(resolveBookmark(bookmark));\n      }\n    };\n    const mergeBackward = (editor, rng, fromLi, toLi) => {\n      const bookmark = createBookmark(rng);\n      mergeLiElements(editor.dom, fromLi, toLi);\n      const resolvedBookmark = resolveBookmark(bookmark);\n      editor.selection.setRng(resolvedBookmark);\n    };\n    const backspaceDeleteFromListToListCaret = (editor, isForward) => {\n      const dom = editor.dom, selection = editor.selection;\n      const selectionStartElm = selection.getStart();\n      const root = getClosestEditingHost(editor, selectionStartElm);\n      const li = dom.getParent(selection.getStart(), 'LI', root);\n      if (li) {\n        const ul = li.parentElement;\n        if (ul === editor.getBody() && isEmpty$1(dom, ul)) {\n          return true;\n        }\n        const rng = normalizeRange(selection.getRng());\n        const otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), 'LI', root);\n        if (otherLi && otherLi !== li) {\n          editor.undoManager.transact(() => {\n            if (isForward) {\n              mergeForward(editor, rng, otherLi, li);\n            } else {\n              if (isFirstChild(li)) {\n                outdentListSelection(editor);\n              } else {\n                mergeBackward(editor, rng, li, otherLi);\n              }\n            }\n          });\n          return true;\n        } else if (!otherLi) {\n          if (!isForward && rng.startOffset === 0 && rng.endOffset === 0) {\n            editor.undoManager.transact(() => {\n              flattenListSelection(editor);\n            });\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const removeBlock = (dom, block, root) => {\n      const parentBlock = dom.getParent(block.parentNode, dom.isBlock, root);\n      dom.remove(block);\n      if (parentBlock && dom.isEmpty(parentBlock)) {\n        dom.remove(parentBlock);\n      }\n    };\n    const backspaceDeleteIntoListCaret = (editor, isForward) => {\n      const dom = editor.dom;\n      const selectionStartElm = editor.selection.getStart();\n      const root = getClosestEditingHost(editor, selectionStartElm);\n      const block = dom.getParent(selectionStartElm, dom.isBlock, root);\n      if (block && dom.isEmpty(block)) {\n        const rng = normalizeRange(editor.selection.getRng());\n        const otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), 'LI', root);\n        if (otherLi) {\n          const findValidElement = element => contains$1([\n            'td',\n            'th',\n            'caption'\n          ], name(element));\n          const findRoot = node => node.dom === root;\n          const otherLiCell = closest(SugarElement.fromDom(otherLi), findValidElement, findRoot);\n          const caretCell = closest(SugarElement.fromDom(rng.startContainer), findValidElement, findRoot);\n          if (!equals(otherLiCell, caretCell, eq)) {\n            return false;\n          }\n          editor.undoManager.transact(() => {\n            removeBlock(dom, block, root);\n            mergeWithAdjacentLists(dom, otherLi.parentNode);\n            editor.selection.select(otherLi, true);\n            editor.selection.collapse(isForward);\n          });\n          return true;\n        }\n      }\n      return false;\n    };\n    const backspaceDeleteCaret = (editor, isForward) => {\n      return backspaceDeleteFromListToListCaret(editor, isForward) || backspaceDeleteIntoListCaret(editor, isForward);\n    };\n    const hasListSelection = editor => {\n      const selectionStartElm = editor.selection.getStart();\n      const root = getClosestEditingHost(editor, selectionStartElm);\n      const startListParent = editor.dom.getParent(selectionStartElm, 'LI,DT,DD', root);\n      return startListParent || getSelectedListItems(editor).length > 0;\n    };\n    const backspaceDeleteRange = editor => {\n      if (hasListSelection(editor)) {\n        editor.undoManager.transact(() => {\n          editor.execCommand('Delete');\n          normalizeLists(editor.dom, editor.getBody());\n        });\n        return true;\n      }\n      return false;\n    };\n    const backspaceDelete = (editor, isForward) => {\n      const selection = editor.selection;\n      return !isWithinNonEditableList(editor, selection.getNode()) && (selection.isCollapsed() ? backspaceDeleteCaret(editor, isForward) : backspaceDeleteRange(editor));\n    };\n    const setup$1 = editor => {\n      editor.on('ExecCommand', e => {\n        const cmd = e.command.toLowerCase();\n        if ((cmd === 'delete' || cmd === 'forwarddelete') && hasListSelection(editor)) {\n          normalizeLists(editor.dom, editor.getBody());\n        }\n      });\n      editor.on('keydown', e => {\n        if (e.keyCode === global$3.BACKSPACE) {\n          if (backspaceDelete(editor, false)) {\n            e.preventDefault();\n          }\n        } else if (e.keyCode === global$3.DELETE) {\n          if (backspaceDelete(editor, true)) {\n            e.preventDefault();\n          }\n        }\n      });\n    };\n\n    const get = editor => ({\n      backspaceDelete: isForward => {\n        backspaceDelete(editor, isForward);\n      }\n    });\n\n    const updateList = (editor, update) => {\n      const parentList = getParentList(editor);\n      if (parentList === null || isWithinNonEditableList(editor, parentList)) {\n        return;\n      }\n      editor.undoManager.transact(() => {\n        if (isObject(update.styles)) {\n          editor.dom.setStyles(parentList, update.styles);\n        }\n        if (isObject(update.attrs)) {\n          each(update.attrs, (v, k) => editor.dom.setAttrib(parentList, k, v));\n        }\n      });\n    };\n\n    const parseAlphabeticBase26 = str => {\n      const chars = reverse(trim(str).split(''));\n      const values = map(chars, (char, i) => {\n        const charValue = char.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0) + 1;\n        return Math.pow(26, i) * charValue;\n      });\n      return foldl(values, (sum, v) => sum + v, 0);\n    };\n    const composeAlphabeticBase26 = value => {\n      value--;\n      if (value < 0) {\n        return '';\n      } else {\n        const remainder = value % 26;\n        const quotient = Math.floor(value / 26);\n        const rest = composeAlphabeticBase26(quotient);\n        const char = String.fromCharCode('A'.charCodeAt(0) + remainder);\n        return rest + char;\n      }\n    };\n    const isUppercase = str => /^[A-Z]+$/.test(str);\n    const isLowercase = str => /^[a-z]+$/.test(str);\n    const isNumeric = str => /^[0-9]+$/.test(str);\n    const deduceListType = start => {\n      if (isNumeric(start)) {\n        return 2;\n      } else if (isUppercase(start)) {\n        return 0;\n      } else if (isLowercase(start)) {\n        return 1;\n      } else if (isEmpty(start)) {\n        return 3;\n      } else {\n        return 4;\n      }\n    };\n    const parseStartValue = start => {\n      switch (deduceListType(start)) {\n      case 2:\n        return Optional.some({\n          listStyleType: Optional.none(),\n          start\n        });\n      case 0:\n        return Optional.some({\n          listStyleType: Optional.some('upper-alpha'),\n          start: parseAlphabeticBase26(start).toString()\n        });\n      case 1:\n        return Optional.some({\n          listStyleType: Optional.some('lower-alpha'),\n          start: parseAlphabeticBase26(start).toString()\n        });\n      case 3:\n        return Optional.some({\n          listStyleType: Optional.none(),\n          start: ''\n        });\n      case 4:\n        return Optional.none();\n      }\n    };\n    const parseDetail = detail => {\n      const start = parseInt(detail.start, 10);\n      if (is$2(detail.listStyleType, 'upper-alpha')) {\n        return composeAlphabeticBase26(start);\n      } else if (is$2(detail.listStyleType, 'lower-alpha')) {\n        return composeAlphabeticBase26(start).toLowerCase();\n      } else {\n        return detail.start;\n      }\n    };\n\n    const open = editor => {\n      const currentList = getParentList(editor);\n      if (!isOlNode(currentList) || isWithinNonEditableList(editor, currentList)) {\n        return;\n      }\n      editor.windowManager.open({\n        title: 'List Properties',\n        body: {\n          type: 'panel',\n          items: [{\n              type: 'input',\n              name: 'start',\n              label: 'Start list at number',\n              inputMode: 'numeric'\n            }]\n        },\n        initialData: {\n          start: parseDetail({\n            start: editor.dom.getAttrib(currentList, 'start', '1'),\n            listStyleType: Optional.from(editor.dom.getStyle(currentList, 'list-style-type'))\n          })\n        },\n        buttons: [\n          {\n            type: 'cancel',\n            name: 'cancel',\n            text: 'Cancel'\n          },\n          {\n            type: 'submit',\n            name: 'save',\n            text: 'Save',\n            primary: true\n          }\n        ],\n        onSubmit: api => {\n          const data = api.getData();\n          parseStartValue(data.start).each(detail => {\n            editor.execCommand('mceListUpdate', false, {\n              attrs: { start: detail.start === '1' ? '' : detail.start },\n              styles: { 'list-style-type': detail.listStyleType.getOr('') }\n            });\n          });\n          api.close();\n        }\n      });\n    };\n\n    const queryListCommandState = (editor, listName) => () => {\n      const parentList = getParentList(editor);\n      return isNonNullable(parentList) && parentList.nodeName === listName;\n    };\n    const registerDialog = editor => {\n      editor.addCommand('mceListProps', () => {\n        open(editor);\n      });\n    };\n    const register$2 = editor => {\n      editor.on('BeforeExecCommand', e => {\n        const cmd = e.command.toLowerCase();\n        if (cmd === 'indent') {\n          indentListSelection(editor);\n        } else if (cmd === 'outdent') {\n          outdentListSelection(editor);\n        }\n      });\n      editor.addCommand('InsertUnorderedList', (ui, detail) => {\n        toggleList(editor, 'UL', detail);\n      });\n      editor.addCommand('InsertOrderedList', (ui, detail) => {\n        toggleList(editor, 'OL', detail);\n      });\n      editor.addCommand('InsertDefinitionList', (ui, detail) => {\n        toggleList(editor, 'DL', detail);\n      });\n      editor.addCommand('RemoveList', () => {\n        flattenListSelection(editor);\n      });\n      registerDialog(editor);\n      editor.addCommand('mceListUpdate', (ui, detail) => {\n        if (isObject(detail)) {\n          updateList(editor, detail);\n        }\n      });\n      editor.addQueryStateHandler('InsertUnorderedList', queryListCommandState(editor, 'UL'));\n      editor.addQueryStateHandler('InsertOrderedList', queryListCommandState(editor, 'OL'));\n      editor.addQueryStateHandler('InsertDefinitionList', queryListCommandState(editor, 'DL'));\n    };\n\n    const setupTabKey = editor => {\n      editor.on('keydown', e => {\n        if (e.keyCode !== global$3.TAB || global$3.metaKeyPressed(e)) {\n          return;\n        }\n        editor.undoManager.transact(() => {\n          if (e.shiftKey ? outdentListSelection(editor) : indentListSelection(editor)) {\n            e.preventDefault();\n          }\n        });\n      });\n    };\n    const setup = editor => {\n      if (shouldIndentOnTab(editor)) {\n        setupTabKey(editor);\n      }\n      setup$1(editor);\n    };\n\n    const setupToggleButtonHandler = (editor, listName) => api => {\n      const toggleButtonHandler = e => {\n        api.setActive(inList(e.parents, listName));\n        api.setEnabled(!isWithinNonEditableList(editor, e.element));\n      };\n      return setNodeChangeHandler(editor, toggleButtonHandler);\n    };\n    const register$1 = editor => {\n      const exec = command => () => editor.execCommand(command);\n      if (!editor.hasPlugin('advlist')) {\n        editor.ui.registry.addToggleButton('numlist', {\n          icon: 'ordered-list',\n          active: false,\n          tooltip: 'Numbered list',\n          onAction: exec('InsertOrderedList'),\n          onSetup: setupToggleButtonHandler(editor, 'OL')\n        });\n        editor.ui.registry.addToggleButton('bullist', {\n          icon: 'unordered-list',\n          active: false,\n          tooltip: 'Bullet list',\n          onAction: exec('InsertUnorderedList'),\n          onSetup: setupToggleButtonHandler(editor, 'UL')\n        });\n      }\n    };\n\n    const setupMenuButtonHandler = (editor, listName) => api => {\n      const menuButtonHandler = e => api.setEnabled(inList(e.parents, listName) && !isWithinNonEditableList(editor, e.element));\n      return setNodeChangeHandler(editor, menuButtonHandler);\n    };\n    const register = editor => {\n      const listProperties = {\n        text: 'List properties...',\n        icon: 'ordered-list',\n        onAction: () => editor.execCommand('mceListProps'),\n        onSetup: setupMenuButtonHandler(editor, 'OL')\n      };\n      editor.ui.registry.addMenuItem('listprops', listProperties);\n      editor.ui.registry.addContextMenu('lists', {\n        update: node => {\n          const parentList = getParentList(editor, node);\n          return isOlNode(parentList) ? ['listprops'] : [];\n        }\n      });\n    };\n\n    var Plugin = () => {\n      global$6.add('lists', editor => {\n        register$3(editor);\n        if (!editor.hasPlugin('rtc', true)) {\n          setup(editor);\n          register$2(editor);\n        } else {\n          registerDialog(editor);\n        }\n        register$1(editor);\n        register(editor);\n        return get(editor);\n      });\n    };\n\n    Plugin();\n\n})();\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}